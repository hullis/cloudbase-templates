# vue 源码

```js
//AMD规范和commonJS规范,都是为了模块化
//AMD规范则是非同步加载模块，允许指定回调函数。
//CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。
//是个匿名函数,该匿名函数并没自执行 设计参数 window，并传入window对象。不污染全局变量，也不会被别的代码污染
(function (global, factory) {
//检查 CommonJS,CommonJS模块作用域，每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见,
//所有代码都运行在模块作用域，不会污染全局作用域，
//模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。
//要想让模块再次运行，必须清除缓存。模块加载的顺序，按照其在代码中出现的顺序
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  //AMD异步模块定义 检查JavaScript依赖管理库 require.js 的存在
  typeof define === 'function' && define.amd ? define(factory) : 
  (global = global || self, global.Vue = factory());
}(this, function () {
   'use strict';

  /*  */
  //冻结对象，一个被冻结的对象再也不能被修改。可以使用Object.freeze提升性能
  var emptyObject = Object.freeze({});

//判断未定义
  function isUndef (v) {
    return v === undefined || v === null
  }
//判断已定义
  function isDef (v) {
    return v !== undefined && v !== null
  }

  function isTrue (v) {
    return v === true
  }

  function isFalse (v) {
    return v === false
  }

  /**
   *  判断为原始类型
   */
  function isPrimitive (value) {
    return (
      typeof value === 'string' ||
      typeof value === 'number' ||
      // $flow-disable-line
      typeof value === 'symbol' ||
      typeof value === 'boolean'
    )
  }

  // 判断为对象
  function isObject (obj) {
    return obj !== null && typeof obj === 'object'
  }

  /**
   * 获取值的原始类型字符串，例如，[对象]
   */
  var _toString = Object.prototype.toString;
// 切割引用类型得到后面的基本类型，例如：[object RegExp] 得到的就是 RegExp
  function toRawType (value) {
    return _toString.call(value).slice(8, -1)
  }

   //判断纯粹的对象："纯粹的对象"，就是通过 {}、new Object()、Object.create(null) 创建的对象
  function isPlainObject (obj) {
    return _toString.call(obj) === '[object Object]'
  }
  // 判断原生引用类型
  function isRegExp (v) {
    return _toString.call(v) === '[object RegExp]'
  }

  /**
   * 检查val是否是有效的数组索引，验证是否是一个非无穷大的正整数。
   */
  function isValidArrayIndex (val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val)
  }
  // 判断是否是Promise
  function isPromise (val) {
    return (
      isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function'
    )
  }

  /**
   * 将值转换为字符串。
   */
  function toString (val) {
    return val == null
      ? ''
      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
        ? JSON.stringify(val, null, 2)
        : String(val) 
  }

  /**
  将输入值转换为数字以便持久化。如果转换失败，则返回原始字符串。
   */
  function toNumber (val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n
  }

  /**
   *  makeMap 方法将字符串切割，放到map中，用于校验其中的某个字符串是否存在（区分大小写）于map中
   */
  function makeMap ( str, expectsLowerCase ) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase
      ? function (val) { return map[val.toLowerCase()]; }
      : function (val) { return map[val]; }
  }

  /**
   * 检查标记是否为内置标记。
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * 检查属性是否为保留属性。
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * 从数组中删除项
   */
  function remove (arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1)
      }
    }
  }

  /**
   * 检查对象是否具有该属性。
   * hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn (obj, key) {
    return hasOwnProperty.call(obj, key)
  }

  /**
   * 创建纯函数的缓存版本。
   * 高阶函数cached函数，输入参数为函数，返回值为函数。利用了闭包变量不会被回收的特点，
   * 可以缓存变量,下次再调用的时候可以从缓存中读取，如果存在缓存就使用缓存，如果不存在就重新计算下
   */
  function cached (fn) {
    var cache = Object.create(null);
    return (function cachedFn (str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str))
    })
  }

  /**
   * 驼峰化一个连字符连接的字符串
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
  });

  /**
   * 将字符串首字母大写。
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  });

  /**
   * 用字符号连接一个驼峰的字符串
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase()
  });

  /**
   * 高级函数,简单绑定polyfill，用于不支持它的环境，例如PhantomJS 1.x;
   * Polyfill是一个js库，主要抚平不同浏览器之间对js实现的差异
   */

  /* istanbul ignore next */
  function polyfillBind (fn, ctx) {
    function boundFn (a) {
      var l = arguments.length;
      return l
        ? l > 1
          ? fn.apply(ctx, arguments)
          : fn.call(ctx, a)
        : fn.call(ctx)
    }

    boundFn._length = fn.length;
    return boundFn
  }

  function nativeBind (fn, ctx) {
    return fn.bind(ctx)
  }
  Function.prototype.bind()
// bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，
// 而其余参数将作为新函数的参数，供调用时使用。
  var bind = Function.prototype.bind
    ? nativeBind
    : polyfillBind;

  /**
   * 将类似数组的对象转换为实数组
   */
  function toArray (list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret
  }

  /**
   *  将多个属性插入目标的对象
   */
  function extend (to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to
  }

  /**
   * 将对象数组合并为单个对象。
   */
  function toObject (arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res
  }

  /* eslint-disable no-unused-vars */

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
   */
  function noop (a, b, c) {}

  /**
   * 总是返回false。
   */
  var no = function (a, b, c) { return false; };

  /* eslint-enable no-unused-vars */

  /**
   * 返回相同的值
   */
  var identity = function (_) { return _; };

  /**
   * 从编译器模块生成包含静态键的字符串。
   */
  function genStaticKeys (modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || [])
    }, []).join(',')
  }

  /**高级函数 对对象的浅相等进行判断
   * ES6有一个方法来判断两个对象是否相等  Object.is()  这个方法判断的是a和b是不是同一个指针的对象
   * 判断a、b两个集合是否相等，如果a包含于b，且b包含于a，则 A = B
   *判断两个对象相等 （判断两个对象键名与键值对应相同 而非指引用地址相同）
   */
  function looseEqual (a, b) {
    //判断是否恒相等
    if (a === b) { return true }
    //判断是否为对象
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        // 当a,b都是数组时
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          //递归判断两个数组中的每一项
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i])
          })
          // 否则判断a,b是否为Date类型，
        } else if (a instanceof Date && b instanceof Date) {
          //使a和b恒相等
          return a.getTime() === b.getTime()
          //当a,b是对象时，首先判断length长度是否相同，长度相同再判断每个属性对应的属于值是否相同
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key])
          })
        } else {
          return false
        }
      } catch (e) {
        return false
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b)
    } else {
      return false
    }
  }

  /**
   * 返回索引，如果没找到返回-1，否则执行looseEqual()
   */
  function looseIndexOf (arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) { return i }
    }
    return -1
  }

  /**
   * 确保函数只调用一次。
   */
  function once (fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    }
  }

//   cached
// polyfillBind
// looseEqual
//闭包，类型判断，函数之间的相互调用调用



//定义变量
  var SSR_ATTR = 'data-server-rendered';// 服务端渲染
  // 全局函数 component、directive、filter
  var ASSET_TYPES = [
    'component',
    'directive',
    'filter'
  ];
  // 生命周期
  var LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch'
  ];

  /*  */


  // 全局配置
  var config = ({
    /**
     * 选项合并策略（用于core/util/options）
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * 是否抑制警告
     */
    silent: false,

    /**
     * 启动时显示生产模式提示消息？
     */
    productionTip: "development" !== 'production',

    /**
     * 是否启用devtools
     */
    devtools: "development" !== 'production',

    /**
     * 是否记录性能
     */
    performance: false,

    /**
     * 观察程序错误的错误处理程序
     */
    errorHandler: null,

    /**
     * 观察者警告的警告处理程序
     */
    warnHandler: null,

    /**
     * 忽略某些自定义元素
     */
    ignoredElements: [],

    /**
     * v-on的自定义用户密钥别名
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * 检查标记是否已保留，以便无法将其注册为组件。这取决于平台，可能会被覆盖。
     */
    isReservedTag: no,

    /**
     检查属性是否已保留，以使其不能用作组件属性。这取决于平台，可能会被覆盖。
     */
    isReservedAttr: no,

    /**
     * 检查标记是否为未知元素。依赖于平台。
     */
    isUnknownElement: no,

    /**
     * 获取元素的命名空间
     */
    getTagNamespace: noop,

    /**
     * 解析特定平台的真实标记名。
     */
    parsePlatformTagName: identity,

    /**
     * 检查属性是否必须使用属性绑定，例如valuePlatform dependent。
     */
    mustUseProp: no,

    /**
     * 异步执行更新。打算由Vue Test Utils使用，如果设置为false，这将显著降低性能。
     */
    async: true,

    /**
     * 因遗留原因暴露
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  });

  /*  */

  /**
  用于解析html标记、组件名称和属性路径的unicode字母。
  使用https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname 
   */
  var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

  /**
   * 检查字符串是否以$或_开头
   */
  function isReserved (str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F
  }

  /**
   * 定义属性。
   * 在一个对象上定义一个属性的构造函数，其中 !!enumerable 强制转换 boolean
   */
  function def (obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * 解析简单路径。
   */
  var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
  function parsePath (path) {
    if (bailRE.test(path)) {
      return
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) { return }
        obj = obj[segments[i]];
      }
      return obj
    }
  }

  /*  */

  var hasProto = '__proto__' in {};

  // 判断浏览器环境
  var inBrowser = typeof window !== 'undefined';
  // 运行环境是微信
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  //浏览器 UA 判断
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  // IE的内核是trident
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  // 判断 android ios
  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
  // 判断chrome
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
  var isPhantomJS = UA && /phantomjs/.test(UA);
  var isFF = UA && UA.match(/firefox\/(\d+)/);

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = ({}).watch;

/*https://blog.csdn.net/dj0379/article/details/52883315
  1.passive是什么？passived主要用于优化浏览器页面滚动的性能，Chrome提出的一个新的浏览器特性：Web开发者通过一个新的属性passive来告诉浏览器，
  当前页面内注册的事件监听器内部是否会调用preventDefault函数来阻止事件的默认行为，
  以便浏览器根据这个信息更好地做出决策来优化页面性能。当属性passive的值为true的时候，
  代表该监听器内部不会调用preventDefault函数来阻止默认滑动行为，Chrome浏览器称这类型的监听器为被动
  （passive）监听器。目前Chrome主要利用该特性来优化页面的滑动性能，所以Passive Event Listeners特性
  当前仅支持mousewheel/touch相关事件
  2.Passive Event Listeners特性是为了提高页面的滑动流畅度而设计的，页面滑动流畅度的提升，
  直接影响到用户对这个页面最直观的感受。
  3.passive的简单实现
  function handler(event) {
    console.log(event.type);
  }
  document.addEventListener("mousewheel", handler, {passive:true});
*/


  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', ({
        get: function get () {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      })); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // 视图服务器渲染器可以设置视图环境
  var _isServer;
  var isServerRendering = function () {
    if (_isServer === undefined) {
      if (!inBrowser && !inWeex && typeof global !== 'undefined') {
        // 检测是否存在vue服务器呈现程序并避免网页包填充进程
        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer
  };

  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  // 判断一个函数是否为 JavaScript 内置方法的方法
  function isNative (Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
  }
  // 判断是否含有 Symbol 类型
  var hasSymbol =
    typeof Symbol !== 'undefined' && isNative(Symbol) &&
    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  //判断Set是否为内置对象
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /*@__PURE__*/(function () {
      function Set () {
        this.set = Object.create(null);
      }
      // Set.prototype.has()方法接受一个参数，返回一个布尔值，表明该参数是否存在于Set对象中
      Set.prototype.has = function has (key) {
        return this.set[key] === true
      };
      // Set.prototype.add()方法用于向Set对象末尾添加一个指定的值，并返回Set对象本身。如果值已存在，则添加不会成功
      Set.prototype.add = function add (key) {
        this.set[key] = true;
      };
      // 用来清空一个Set对象的所有元素，没有返回值
      Set.prototype.clear = function clear () {
        this.set = Object.create(null);
      };

      return Set;
    }());
  }

  /* 日志信息模块 */

  var warn = noop;
  var tip = noop;
  //generateComponentTrace这个function，这个方法初始化的值也是noop，什么都没有做，目的是解决流量检查问题
  var generateComponentTrace = (noop);
  var formatComponentName = (noop);
  {
    var hasConsole = typeof console !== 'undefined';
    // 这个正则就是把连接符转换成的驼峰写法, 并且第一个字符大写^|[-_]的意思是字符串的开头, 或者 -_ 后面的一个字符
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function (str) { return str
      .replace(classifyRE, function (c) { return c.toUpperCase(); })
      .replace(/[-_]/g, ''); };
    //控制台打印错误提示
    warn = function (msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';
      //如果配置的console.silent, 就不会打印错误日志
      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && (!config.silent)) {
        console.error(("[Vue warn]: " + msg + trace));
      }
    };
    //控制台打警告提示
    tip = function (msg, vm) {
      if (hasConsole && (!config.silent)) {
        console.warn("[Vue tip]: " + msg + (
          vm ? generateComponentTrace(vm) : ''
        ));
      }
    };
    //格式化组件名称
    formatComponentName = function (vm, includeFile) {
      //如果是根组件, 它会有一个属性.$root 指向它自己
      if (vm.$root === vm) {
        return '<Root>'
      }
      // 先判断option有没自定义name,如果没有就用vm.name, 这个name应该是vue自己配置的一个随机数
      var options = typeof vm === 'function' && vm.cid != null
        ? vm.options
        : vm._isVue
          ? vm.$options || vm.constructor.options
          : vm;
      var name = options.name || options._componentTag;
      var file = options.__file;
      if (!name && file) {
        //如果没有name，但存在此文件，则取文件名
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (
        //返回驼峰组件名称
        (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
        //提示文件路径出错
        (file && includeFile !== false ? (" at " + file) : '')
      )
    };
    //返回一个str循环n次的字符串,例如str="a",n=5,则返回"aaaaa"
    var repeat = function (str, n) {
      var res = '';
      while (n) {
        if (n % 2 === 1) { res += str; }
        if (n > 1) { str += str; }
        n >>= 1;
      }
      return res
    };
      //生成组件跟踪路径（组件数规则）
    generateComponentTrace = function (vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return '\n\nfound in\n\n' + tree
          .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
              ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
              : formatComponentName(vm))); })
          .join('\n')
      } else {
        return ("\n\n(found in " + (formatComponentName(vm)) + ")")
      }
    };
  }
  var uid = 0;
  // Vue核心：数据监听最重要之一的 Dep
  // dep是一个可观察的，可以有多个订阅它的指令
  // Dep是订阅者Watcher对应的数据依赖
  // Dep 相当于把 Observe 监听到的信号做一个收集
  // 然后通过dep.notify()再通知到对应 Watcher ，从而进行视图更新。
  // 要实现数据的响应机制 即数据变化 视图变化
// 在vue的响应机制中 我们要使用观察模式来监听数据的变化 
// 因此 在vue中我们要实现Dep和watcher  Dep的主要作用是收集依赖 在vue中的每一个响应属性 
// 都会创建一个dep对象 负责手机依赖于该属性的所有依赖 即订阅者 并在数据更新时候发布通知 
// 调用watcher对象中的update方法去更新视图 简单说明就是在数据劫持监听中的get去添加依赖 在set中去发布通知 
  var Dep = function Dep () {
    this.id = uid++;
    this.subs = [];
  };
  //向Dep实例中的subs数组中添加监视器对象
  Dep.prototype.addSub = function addSub (sub) {
    this.subs.push(sub);
  };
//删除Dep实例中subs数组中指定的监视器对象
  Dep.prototype.removeSub = function removeSub (sub) {
    remove(this.subs, sub);
  };
//设置某个Watcher的依赖
//这里添加了Dep.target是否存在的判断，目的是判断是不是Watcher的构造函数调用
//也就是说判断他是Watcher的this.get调用的，而不是普通调用
//如果target存在就会继续监听
  Dep.prototype.depend = function depend () {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };
  //通知监听者
  // 变量Dep的subs数组中的监视器并调用其的update方法
  Dep.prototype.notify = function notify () {
    var subs = this.subs.slice();
    if (!config.async) {
      // 如果未运行异步，则不会在调度程序中对sub进行排序
      subs.sort(function (a, b) { return a.id - b.id; });
    }
     //通知所有绑定 Watcher。调用watcher的update()
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // 正在评估的当前目标观察程序。
  Dep.target = null;
  var targetStack = [];
  // 如果Dep实例的target的值为真向targetStack数组尾部添加此监视器，设置当前Dep实例的target为传入的监视器。
  function pushTarget (target) {
    targetStack.push(target);
    Dep.target = target;
  }
  // 从targetStack数组中的头部取出一个监视器对象赋值给Dep实例的target属性。
  function popTarget () {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
  }

  // VNode是基于面向对象进行设计的
  // 视图更新最重要的VNode
  // 将template模板描述成 VNode，然后一系列操作之后通过VNode形成真实DOM进行挂载
  // 更新的时候对比旧的VNode和新的VNode，只更新有变化的那一部分，提高视图更新速度
  var VNode = function VNode (
    tag,
    data,
    children,
    text,
    elm,
    context,
    componentOptions,
    asyncFactory
  ) {
    this.tag = tag; //标签属性
    this.data = data;//渲染成真实DOM后，节点上到class attr style 事件等
    this.children = children;//子节点，也上vnode
    this.text = text; // 文本
    this.elm = elm;//对应着真实的dom节点
    this.ns = undefined;//当前节点的namespace（命名空间）
    this.context = context;//编译的作用域
    this.fnContext = undefined;// 函数化组件上下文
    this.fnOptions = undefined;// 函数化组件配置项
    this.fnScopeId = undefined;// 函数化组件ScopeId
    this.key = data && data.key;//只有绑定数据下存在，在diff的过程中可以提高性能
    this.componentOptions = componentOptions;// 通过vue组件生成的vnode对象，若是普通dom生成的vnode，则此值为空
    this.componentInstance = undefined;//当前组件实例
    this.parent = undefined;//vnode、组件的占位节点
    this.raw = false; //是否为原生HTML或只是普通文本
    this.isStatic = false;  //静态节点标识 || keep-alive
    this.isRootInsert = true; // 是否作为根节点插入
    this.isComment = false;// 是否为注释节点
    this.isCloned = false; //是否为克隆节点
    this.isOnce = false; //是否为v-once节点
    this.asyncFactory = asyncFactory;// 异步工厂方法
    this.asyncMeta = undefined; //异步Meta
    this.isAsyncPlaceholder = false;//是否为异步占位
  };

  var prototypeAccessors = { child: { configurable: true } };
  prototypeAccessors.child.get = function () {
    return this.componentInstance
  };
  // 通过 Object.defineProperties 为 VNode 的原型绑定了对象 prototypeAccessors ，
  // prototypeAccessors 设置 child 是可修改的状态。
  Object.defineProperties( VNode.prototype, prototypeAccessors );
  /*创建一个空VNode节点*/
  var createEmptyVNode = function (text) {
    if ( text === void 0 ) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node
  };
  /*创建一个文本节点*/
  function createTextVNode (val) {
    return new VNode(undefined, undefined, undefined, String(val))
  }

  // cloneVNode 克隆VNode节点
  function cloneVNode (vnode) {
    var cloned = new VNode(
      vnode.tag,
      vnode.data,
      // 克隆子数组以避免在克隆时突变原始数组的子数组
      vnode.children && vnode.children.slice(),
      vnode.text,
      vnode.elm,
      vnode.context,
      vnode.componentOptions,
      vnode.asyncFactory
    );
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned
  }

/*取得原生数组的原型*/
  var arrayProto = Array.prototype;
  /*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/
  var arrayMethods = Object.create(arrayProto);

  /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，
  截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/
  var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
  ];

  // 数组⽐较特别，它的操作⽅法不会触发setter，需要特别处理。修改数组7个变更⽅法使其可以发送更新通知
  methodsToPatch.forEach(function (method) {
    /*将数组的原生方法缓存起来*/
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
       /*调用原生的数组方法*/
      var result = original.apply(this, args);
      /*数组新插入的元素需要重新进行observe才能响应式*/
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break
        case 'splice':
          inserted = args.slice(2);
          break
      }
      // 方法用于异步监视数组发生的变化,类似于针对对象的 Object.observe() 。
      if (inserted) { ob.observeArray(inserted); }
      /*dep通知所有注册的观察者进行响应式处理*/
      ob.dep.notify();
      return result
    });
  });

  // 一般也是用来获取一个JSON对象中所有属性，
  // getOwnPropertyNames 获取对象自身的可枚举和不可枚举属性,不包括属性名为Symbol值的属性 
  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */
  var shouldObserve = true;
  // 这个方法是vue内部对逻辑的一个优化,如果当前组件是根组件,那么根组件是不应该有props的。
  // toggleObserving就是禁止掉根组件 props的依赖收集
  function toggleObserving (value) {
    shouldObserve = value;
  }

  // 附加到每个被观察对象的观察者类。一旦附加，观察者将目标对象的属性键转换为getter/setter，用于收集依赖项和分派更新。
  // Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。
// 如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。
  export class Observer {
  var Observer = function Observer (value) {
    this.value = value;//这个就是传入的要被监听的对象
    this.dep = new Dep();// 保存新的Dep实例
    this.vmCount = 0;// 设置vmCount的值为0
    // 为被监听对象定义了一个 __ob__ 属性，这个属性的值就是当前 Observer 实例对象
    // 其中 def 函数其实就是 Object.defineProperty 函数的简单封装
    //之所以这里使用 def 函数定义 __ob__ 属性是因为这样可以定义不可枚举的属性，
    // 这样后面遍历数据对象的时候就能够防止遍历到 __ob__ 属性
    def(value, '__ob__', this);
      /*
          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。
          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，
          则直接覆盖数组对象的原型。
      */
    if (Array.isArray(value)) {
      if (hasProto) {
        /*直接覆盖原型的方法来修改目标对象*/
        protoAugment(value, arrayMethods);
      } else {
        /*定义（覆盖）目标对象或数组的某一个方法*/
        copyAugment(value, arrayMethods, arrayKeys);
      }
      /*如果是数组则需要遍历数组的每一个成员进行observe*/
      this.observeArray(value);
    } else {
      // 如果是对象，遍历执行响应式的操作
      this.walk(value);
    }
  };

  // 遍历每个属性并将它们转换为getter/setter。此方法只应在值类型为Object时调用。
  Observer.prototype.walk = function walk (obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i]);
    }
  };

  // 观察数组项的列表，如果是数组，遍历每一项，对每一项进行一次observe
  Observer.prototype.observeArray = function observeArray (items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

// 直接指定原型
  function protoAugment (target, src) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  //遍历keys,定义（覆盖）目标对象或数组的某一个方法
  function copyAugment (target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

//  尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，
//  如果已有Observer实例则返回现有的Observer实例。
// Vue的响应式数据都会有一个__ob__的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。
  function observe (value, asRootData) {
    /*判断是否是一个对象或者是否是一个虚拟节点*/
    if (!isObject(value) || value instanceof VNode) {
      return
    }
    var ob;
    /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会
    新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (
       /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/
      shouldObserve &&
      !isServerRendering() &&
      (Array.isArray(value) || isPlainObject(value)) &&
      Object.isExtensible(value) &&
      !value._isVue
    ) {
      ob = new Observer(value);
    }
    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob
  }
//   defineReactive 函数最开始初始化 Dep 对象的实例，接着拿到 obj 的属性描述符，
//   然后对子对象递归调用 observe 方法，这样就保证了无论 obj 的结构多复杂，
//   它的所有子属性也能变成响应式的对象，这样我们访问或修改 obj 中一个嵌套较深的属性，
//   也能触发 getter 和 setter。最后利用 Object.defineProperty 去给 obj 的属性 key 添加 getter 和 setter。
// 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是
// 为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新
  function defineReactive$$1 (
    obj,
    key,
    val,
    customSetter,
    shallow
  ) {
    // 这个 dep 常量所引用的 Dep 实例对象
 // 每一个数据字段都通过闭包引用着属于自己的 dep 常量
 // 每次调用 defineReactive 定义访问器属性时，该属性的 setter/getter 都闭包引用了一个属于自己的“筐
    var dep = new Dep();
     // 不可配置的直接返回
  // 获取该字段可能已有的属性描述对象
    var property = Object.getOwnPropertyDescriptor(obj, key);
     // 判断该字段是否是可配置的
  // 一个不可配置的属性是不能使用也没必要使用 Object.defineProperty 改变其属性定义的。
    if (property && property.configurable === false) {
      return
    }
// 保存了来自 property 对象的 get 和 set 
  // 避免原有的 set 和 get 方法被覆盖
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }
  // 递归响应式处理 给每一层属性附加一个Obeserver实例
  // shallow不存在时代表没有__ob__属性 将val进行observe返回一个ob实例赋值给childO
  // 如果是对象继续调用 observe(val) 函数观测该对象从而深度观测数据对象
  // walk 函数中调用 defineReactive 函数时没有传递 shallow 参数，所以该参数是 und
  // 默认就是深度观测
    var childOb = !shallow && observe(val);
    // 数据拦截
  // 通过Object.defineProperty对obj的key进行数据拦截
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      // 进行依赖收集
      get: function reactiveGetter () {
        var value = getter ? getter.call(obj) : val;
        // 判断是否有Dep.target 如果有就代表Dep添加了Watcher实例化对象
        if (Dep.target) {
        // 加入到dep去管理watcher 
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
            // 循环添加watcher
              dependArray(value);
            }
          }
        }
        return value
      },
      set: function reactiveSetter (newVal) {
      // 获取value值 触发依赖收集
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || (newVal !== newVal && value !== value)) {
          return
        }
        /* eslint-enable no-self-compare */
        if (customSetter) {
          customSetter();
        }
        // 对于没有setter的访问器属性 返回
        if (getter && !setter) { return }
        if (setter) {
        // 设置新值
          setter.call(obj, newVal);
        } else {
        // 如果没有setter ，直接给新值
          val = newVal;
        }
        // 递归，对新来的值 对新值进行observe 返回ob实例
        childOb = !shallow && observe(newVal);
        // 当set时触发通知
        dep.notify();
      }
    });
  }
  // 给对象设置一个属性，添加新属性和添加触发更改通知(dep.notify)，如果这个属性不是早已存在
  function set (target, key, val) {
    // 判断数据 是否是undefined或者null
    // 判断数据类型是否是string，number，symbol，boolean
    if (isUndef(target) || isPrimitive(target)
    ) {
      // target必须是对象或者数组，否则发出警告
      warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
    }
    // 如果是数组 并且检查key是否是有效的数组索引
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      // 设置数组长度
      target.length = Math.max(target.length, key);
      // 像数组尾部添加一个新数据，相当于push
      target.splice(key, 1, val);
      return val
    }
    // 如果key在target上 并且不是通过原型链查找的，就直接赋值
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val
    }
    // 声明一个对象ob 值为该target对象中的原型上面的所有方法和属性，表明该数据加入过观察者中
    var ob = (target).__ob__;
    // 如果是vue 或者  检测vue被实例化的次数 vmCount
    if (target._isVue || (ob && ob.vmCount)) {
      warn(
        'Avoid adding reactive properties to a Vue instance or its root $data ' +
        'at runtime - declare it upfront in the data option.'
      );
      return val
    }
      // 如果ob不存在，证明没有添加观察者，不是相应，直接赋值返回
    if (!ob) {
      target[key] = val;
      return val
    }
    // 通过defineReactive将ob.value加入的观察者
    defineReactive$$1(ob.value, key, val);
    // 触发通知更新，通知订阅者obj.value更新数据
    ob.dep.notify();
    return val
  }

    /**
   * 删除属性并在必要时触发更改
   */
  function del (target, key) {
    //判断数据 是否是undefined或者null
    // 判断数据类型是否是string，number，symbol，boolean
    if (isUndef(target) || isPrimitive(target)
    ) {
      warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
    }
    //判断是否是数组，并是否是有效的数组索引
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      // 像数组尾部添加一个新数据，相当于push
      target.splice(key, 1);
      return
    }
    // 声明一个对象ob 值为该target对象中的原型上面的所有方法和属性，表明该数据加入过观察者中
    var ob = (target).__ob__;
    // 如果是vue或者检测vue被实例化的次数vmCount
    if (target._isVue || (ob && ob.vmCount)) {
      warn(
        'Avoid deleting properties on a Vue instance or its root $data ' +
        '- just set it to null.'
      );
      return
    }
    //检查对象是否具有该属性
    if (!hasOwn(target, key)) {
      return
    }
    delete target[key];
    if (!ob) {
      return
    }
    // 触发通知更新，通知订阅者obj.value更新数据
    ob.dep.notify();
  }

  // dependArray函数，其实就是遍历数组，对数组每个元素触发dep.depend收集依赖，因为不能直接对数组进行收集依赖。
  // 在接触数组时收集对数组元素的依赖关系，因为我们不能像属性getter那样拦截数组元素访问。
  function dependArray (value) {
    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
      e = value[i];
      // 判断是否存在__ob__实例，并且每个都调用depend添加wathcer管理
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        // 递归完数组所有内容，直到不是数组，跳出递归
        dependArray(e);
      }
    }
  }
  //选项 el、propsData 的合并策略
  //  选项覆盖策略是处理如何合并父选项值和子选项值转换为最终值。
  // config.optionMergeStrategies定义一个合并策略，其实就是vue的mixins属性
  //propsData 用在全局扩展时进行传递数据
  var strats = config.optionMergeStrategies
  {
    // 在非生产环境下在 strats 策略对象上添加两个策略分别是el和propsData,两个属性值都是函数
    // 这两个策略函数是用来合并 el 选项和 propsData 选项的
    strats.el = strats.propsData = function (parent, child, vm, key) {
      //如果没有传递
      if (!vm) {
        warn(
          "option \"" + key + "\" can only be used during instance " +
          'creation with the `new` keyword.'
        );
      }
      //在生产环境将直接使用默认的策略函数 defaultStrat 来处理 el 和 propsData 这两个选项
      return defaultStrat(parent, child)
    };
  }
 //通过_init方法可以看出，策略函数中的 vm 来自于 mergeOptions 函数的第三个参数，
 //mergeOptions函数传第三个参数，策略中就拿不到vm参数，除了_init方法中调用了mergeOptions函数，其他很多地方都调用了
 //Vue.extend方法中也调用了mergeoptions函数
 //此时在Vue.extend方法中调用了mergeOptions函数，但是没有传第三个参数vm，所以在策略中无法拿到vm，
 //就能得出mergeOptions函数是在实例化时使用new操作符走_init方法还是继承时走的Vue.extend方法
 //子组件是通过实例化子类完成的，子类是通过Vue.extend方法创造出来的，
 //综上得出可以通过if(!vm)判断是否是子组件



  //递归合并两个数据对象,to 对应的是 childVal 产生的纯对象，from 对应 parentVal 产生的纯对象
  function mergeData (to, from) {
    //如果没有form直接返回参数to
    if (!from) { return to }
    var key, toVal, fromVal;
    //如果是Symbol类型
    var keys = hasSymbol
      ? Reflect.ownKeys(from)//返回from的所以属性key组成的数组
      : Object.keys(from);//返回from的属性key，但不包括不可枚举的属性
    //循环from属性key的数组
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      // 如果当前key为object类型，则继续
      if (key === '__ob__') { continue }
      toVal = to[key];
      fromVal = from[key];
      //检查对象是否具有该属性,如果有的话就给to[key]设置fromVal属性
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (
        //判断toVal，fromVal是否是通过"{}"或"new Object"创建,并且toVal!=fromVal
        //这个方法的作用是为了跟其他的 JavaScript对象如 null，数组，宿主对象（documents），
        //DOM 等作区分，因为这些用 typeof 都会返回object
        toVal !== fromVal &&
        isPlainObject(toVal) &&
        isPlainObject(fromVal)
      ) {
        mergeData(toVal, fromVal);
      }
    }
    return to
  }
  //mergeDataOrFn函数永远返回一个函数
  function mergeDataOrFn (
    parentVal,
    childVal,
    vm
  ) {
    //如果没有vm，则说明是子组件选项
    if (!vm) {
      if (!childVal) {
        return parentVal
      }
      if (!parentVal) {
        return childVal
      }
      // 当parentVal和childVal都存在时,我们需要返回一个函数来返回两个函数的合并结果,
      // 不用检查parentVal是否是函数,因为它必须是传递先前合并的函数。
      return function mergedDataFn () {
        return mergeData(
          typeof childVal === 'function' ? childVal.call(this, this) : childVal,
          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
        )
      }
    } else {
      // 当合并处理的是非子组件的选项时 `data` 函数为 `mergedInstanceDataFn` 函数
      return function mergedInstanceDataFn () {
        // instance merge
        var instanceData = typeof childVal === 'function'
          ? childVal.call(vm, vm)
          : childVal;
        var defaultData = typeof parentVal === 'function'
          ? parentVal.call(vm, vm)
          : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData)
        } else {
          return defaultData
        }
      }
    }
  }
  //选项data的合并策略,在 strats 策略对象上添加 data 策略函数，用来合并处理 data 选项
  strats.data = function (
    parentVal,
    childVal,
    vm
  ) {
    //当没有 vm 参数时，说明处理的是子组件的选项
    if (!vm) {
      //判断childVal是不是函数
      if (childVal && typeof childVal !== 'function') {
        warn(
          'The "data" option should be a function ' +
          'that returns a per-instance value in component ' +
          'definitions.',
          vm
        );
        //如果不是函数直接返回 parentVal
        return parentVal
      }
      //无论是否为子组件选项都会调用mergeDataOrFn方法，但是如果是子组件选项会传第三个参数vm,
      // 由此可在mergeDataOrFn函数内判断是否为子组件选项
      return mergeDataOrFn(parentVal, childVal)
    }
    return mergeDataOrFn(parentVal, childVal, vm)
  };

  // 生命周期钩子选项的合并策略
  function mergeHook (
    parentVal,
    childVal
  ) {
    //三目运算符:判断是否有childVal参数，如果有的话判断是否有parentVal参数，
    // 如果有parentVal参数就将childVal与parentVal合并，
    //如果没有 parentVal 则判断 childVal 是不是一个数组
    //如果是数组类型，则直接返回，若不是则将childVal转成数组，说明生命周期钩子是可以写成数组的并会按照数组顺序依次执行
    var res = childVal
      ? parentVal
        ? parentVal.concat(childVal)
        : Array.isArray(childVal)
          ? childVal
          : [childVal]
      : parentVal;
    return res
      ? dedupeHooks(res)
      : res
  }
  //这个函数主要用来处理生命周期钩子的唯一
  function dedupeHooks (hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
      if (res.indexOf(hooks[i]) === -1) {
        res.push(hooks[i]);
      }
    }
    return res
  }
  // LIFECYCLE_HOOKS 常量实际上是由与生命周期钩子同名的字符串组成的数组
  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  // 资源(assets)选项的合并策略
  function mergeAssets (
    parentVal,
    childVal,
    vm,
    key
  ) {
    创建parentVal新对象
    var res = Object.create(parentVal || null);
    // 判断是否有childVal参数
    if (childVal) {
      //主要就是为了判断childVal是否为存粹的对象
      assertObjectType(key, childVal, vm);
      return extend(res, childVal)
    } else {
      return res
    }
  }
  //用来遍历 ASSET_TYPES 常量(component、directive、filter)
  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  // 选项 watch 的合并策略,合并处理 watch 选项的
  strats.watch = function (
    parentVal,
    childVal,
    vm,
    key
  ) {
    // 在 Firefox 浏览器中 Object.prototype 拥有原生的 watch 函数,容易造成迷惑,
    // 所以当发现组件选项是浏览器原生的 watch 时，那说明用户并没有提供 Vue 的 watch 选项，直接重置为 undefined
    if (parentVal === nativeWatch) { parentVal = undefined; }
    if (childVal === nativeWatch) { childVal = undefined; }
    //如果没有childVal(即组件选项是否有 watch 选项),则返回parentVal新对象
    if (!childVal) { return Object.create(parentVal || null) }
    {
      //判断childVal是否为存粹的对象
      assertObjectType(key, childVal, vm);
    }
    //parentVal,则直接返回childVal,即直接使用组件选项的 watch
    if (!parentVal) { return childVal }
    var ret = {};
    //将parentVal插入ret对象
    extend(ret, parentVal);
    //parentVal,childVal都存在，就需要做合并处理
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      //如果parent存在,则将child与parent合并,如果 parent 不存在，直接将 child 转为数组返回
      ret[key$1] = parent
        ? parent.concat(child)
        : Array.isArray(child) ? child : [child];
    }
    return ret
  };

  /**
   * 选项 props、methods、inject、computed 的合并策略
   */
  strats.props =
  strats.methods =
  strats.inject =
  strats.computed = function (
    parentVal,
    childVal,
    vm,
    key
  ) {
    //如果有childVal参数,并且不是生产环境,则需要判断childVal是否为存粹的对象
    if (childVal && "development" !== 'production') {
      assertObjectType(key, childVal, vm);
    }
    //如果没有parentVal参数,则直接返回childVal,即直接使用对应的组件选项
    if (!parentVal) { return childVal }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) { extend(ret, childVal); }
    return ret
  };
  //选项 provide 的合并策略,与data相同
  strats.provide = mergeDataOrFn;
  /*对于 el、propsData 选项使用默认的合并策略 defaultStrat。
  对于 data 选项，使用 mergeDataOrFn 函数进行处理，最终结果是 data 选项将变成一个函数，且该函数的执行结果为真正的数据对象。
  对于 生命周期钩子 选项，将合并成数组，使得父子选项中的钩子函数都能够被执行
  对于 directives、filters 以及 components 等资源选项，父子选项将以原型链的形式被处理，正是因为这样我们才能够在任何地方都使用内置组件、指令等。
  对于 watch 选项的合并处理，类似于生命周期钩子，如果父子选项都有相同的观测字段，将被合并为数组，这样观察者都将被执行。
  对于 props、methods、inject、computed 选项，父选项始终可用，但是子选项会覆盖同名的父选项字段。
  对于 provide 选项，其合并策略使用与 data 选项相同的 mergeDataOrFn 函数。
  以上没有提及到的选项都将使默认选项 defaultStrat。*/

  var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined
      ? parentVal
      : childVal
  };

  // checkComponents函数，校验child对象中组件参数components中的组件名是否符合规范
  function checkComponents (options) {
    for (var key in options.components) {
      validateComponentName(key);
    }
  }
  //组件名的校验
  function validateComponentName (name) {
    if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
      warn(
        'Invalid component name: "' + name + '". Component names ' +
        'should conform to valid custom element name in html5 specification.'
      );
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + name
      );
    }
  }

  // 对props的属性进行一些规范化
  function normalizeProps (options, vm) {
    var props = options.props;
    if (!props) { return }
    var res = {};
    var i, val, name;
    //如果props是数组,则将遍历props,将props转成对象,例如:{ title: {type: null} }
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
      //判断props是否为纯粹的对象
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);//将key驼峰化
        res[name] = isPlainObject(val)
          ? val
          : { type: val };//例如:props: {type: String}
      }
    } else {
      warn(
        "Invalid value for option \"props\": expected an Array or an Object, " +
        "but got " + (toRawType(props)) + ".",
        vm
      );
    }
    options.props = res;
  }

 // 对inject的属性进行一些规范化,与normalizeProps差不多
  function normalizeInject (options, vm) {
    var inject = options.inject;
    if (!inject) { return }
    var normalized = options.inject = {};
    //如果inject是数组,则将循环inject,将inject转成对象,例如:{ title: {form: null} }
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
      //如果inject是纯粹的对象,则循环inject
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val)
          ? extend({ from: key }, val)
          : { from: val };//例如inject: {'title': {from: 'title'} }
      }
    } else {
      warn(
        "Invalid value for option \"inject\": expected an Array or an Object, " +
        "but got " + (toRawType(inject)) + ".",
        vm
      );
    }
  }

   // 对directives的属性进行一些规范化,例如directives: {change:{bind(){...},update(){...}}
  function normalizeDirectives (options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def$$1 = dirs[key];
        //def$$1必须为函数
        if (typeof def$$1 === 'function') {
          dirs[key] = { bind: def$$1, update: def$$1 };
        }
      }
    }
  }
  //判断是否为纯粹的对象
  function assertObjectType (name, value, vm) {
    if (!isPlainObject(value)) {
      warn(
        "Invalid value for option \"" + name + "\": expected an Object, " +
        "but got " + (toRawType(value)) + ".",
        vm
      );
    }
  }

  // 合并策略函数,参数选项合并参数;parent:父实例参数;child:子实例参数;vm:vue实例参数,实例化过程中被调用.
  function mergeOptions (
    parent,
    child,
    vm
  ) {
    {
      //校验child对象中组件参数components中的组件名是否符合规范
      checkComponents(child);
    }
    //判断child是否为函数
    if (typeof child === 'function') {
      child = child.options;
    }
    // Props,Inject,Directives的规范化
    normalizeProps(child, vm);
    normalize(child, vm);
    normalizeDirectives(child);

    //只有合并过的选项会带有_base属性,判断child是否存在_base属性,如果存在则说明已经被合并处理过
    if (!child._base) {
      //将extend和mixins再通过mergeOptions函数与parent合并
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }

    var options = {};
    var key;
    //遍历parent执行mergeField
    for (key in parent) {
      mergeField(key);
    }
    // 遍历child，当parent没有key的时候执行mergeField
    // 如果有key属性，就不需要合并，因为上一步已经合并到options
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    // 该函数主要是通过key获取到对应的合并策略函数，然后执行合并，赋值给options[key]
    function mergeField (key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options
  }

  //用于获取Vue.extend里面定义的构造函数
  function resolveAsset (
    options,
    type,
    id,
    warnMissing
  ) {
    if (typeof id !== 'string') {
      return
    }
    var assets = options[type];
    // 检查assets中是否包含id键,如果有的话直接返回
    if (hasOwn(assets, id)) { return assets[id] }
    //规范键的驼峰命名
    var camelizedId = camelize(id);
    // 如果上一个条件不成立,那么将键转成驼峰后再判断
    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
    //将驼峰后的键的首字母大写
    var PascalCaseId = capitalize(camelizedId);
    // 如果以上条件不成立,那么将键转成驼峰后再将首字母转成大写,再次判断
    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
      warn(
        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
        options
      );
    }
    return res
  }
  //检查一下我们传递的数据是否满足 prop的定义规范
  function validateProp (
    key,
    propOptions,
    propsData,
    vm
  ) {
    var prop = propOptions[key];//获取propOptions中对应的值
    var absent = !hasOwn(propsData, key);//如果propsData没有这个key,则absent为true
    var value = propsData[key];//获取propsData中对应的值
    //判断prop.type是否为布尔类型
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      //如果absent为true,并且prop中不包含'default'
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
        // 如果value为空字符串,获取value与转成驼峰后的key相等
      } else if (value === '' || value === hyphenate(key)) {
        // 判断prop.type是否为String类型
        var stringIndex = getTypeIndex(String, prop.type);
        // 如果为stringIndex类型,或者booleanIndex的优先级比stringIndex的高
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // 当value全等于undefined时，调用getPropDefaultValue方法取prop的默认值
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      //shouldObserve默认值为true
      var prevShouldObserve = shouldObserve;
      //改变shouldObserve的值为true
      toggleObserving(true);
      //判断value是否为一个对象
      observe(value);
      //改变shouldObserve的值为prevShouldObserve的值
      toggleObserving(prevShouldObserve);
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value
  }

  //获取prop的默认值
  function getPropDefaultValue (vm, prop, key) {
    //如果prop中不包含'default'属性,则直接返回undefined
    if (!hasOwn(prop, 'default')) {
      return undefined
    }
    var def = prop.default;
    //如果def为object类型,则发出警告
    if (isObject(def)) {
      warn(
        'Invalid default value for prop "' + key + '": ' +
        'Props with type Object/Array must use a factory function ' +
        'to return the default value.',
        vm
      );
    }
    // vue实例存在，组件实例上的props数据存在，父组件传进来的props中没有该key值的属性，
    // 如果vm实例上_props有，就返回_props上的属性，_props是之前通过proxy代理的
    //是vue做的一点优化，由于函数每次返回的对象都是一个新的引用，当组件更新的时候，
    //为了避免不必要watcher update而设置
    if (vm && vm.$options.propsData &&
      vm.$options.propsData[key] === undefined &&
      vm._props[key] !== undefined
    ) {
      return vm._props[key]
    }
   //如果是function 则调用def.call(vm),否则就返回default属性对应的值
    return typeof def === 'function' && getType(prop.type) !== 'Function'
      ? def.call(vm)
      : def
  }

  // 校验是否通过,先验证required再验证type
  function assertProp (
    prop,
    name,
    value,
    vm,
    absent
  ) {
    //如果必传,但若当前为undefined时,则发出警告
    if (prop.required && absent) {
      warn(
        'Missing required prop: "' + name + '"',
        vm
      );
      return
    }
    //如果非必传时并且value为null,则直接返回
    if (value == null && !prop.required) {
      return
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    //type必须为数组类型
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i], vm);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }

    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
    //如果valid为false,并且expectedTypes有值,则prop 的值 value 与 prop 定义的类型都不匹配,则输出警告
    if (!valid && haveExpectedTypes) {
      warn(
        getInvalidTypeMessage(name, value, expectedTypes),
        vm
      );
      return
    }
    // 判断有没有自定义的校验器，如果有则执行，并在校验器返回false时触发warn
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn(
          'Invalid prop: custom validator check failed for prop "' + name + '".',
          vm
        );
      }
    }
  }
  //props类型检查
  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
  // 获取断言的结果,直到遍历完成或者是 valid 为 true 的时候跳出循环
  function assertType (value, type, vm) {
    var valid;
    // 获取 prop 期望的类型 expectedType,然后对比prop的值value是否和expectedType 匹配
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value;
      valid = t === expectedType.toLowerCase();
      // value 的类型必须是 type 数组里的其中之一
      if (!valid && t === 'object') {
        valid = value instanceof type;
      }
      //判断value是否为纯粹的对象
    } else if (expectedType === 'Object') {
      valid = isPlainObject(value);
    } else if (expectedType === 'Array') {
      //判断value是否为数组
      valid = Array.isArray(value);
    } else {
      try {
        //判断value是否为数组
        valid = value instanceof type;
      } catch (e) {
        warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
        valid = false;
      }
    }
    return {
      valid: valid,
      expectedType: expectedType
    }
  }
  //函数检查
  var functionTypeCheckRE = /^\s*function (\w+)/;

  //将fn参数转成字符串,然后在字符串内查找function
  function getType (fn) {
    var match = fn && fn.toString().match(functionTypeCheckRE);
    return match ? match[1] : ''
  }
  // 判断是否是同一个类型
  function isSameType (a, b) {
    return getType(a) === getType(b)
  }
  //找到 type 和 expectedTypes 匹配的索引并返回
  function getTypeIndex (type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i
      }
    }
    return -1
  }
  //生成警告信息
  function getInvalidTypeMessage (name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', '));
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    // 检查是否需要指定接收值
    if (
      expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      isExplicable(typeof value) &&
      !isBoolean(expectedType, receivedType)
    ) {
      message += " with value " + (styleValue(value, expectedType));
    }
    message += ", got " + receivedType + " ";
    // 检查是否需要指定接收值
    if (isExplicable(receivedType)) {
      message += "with value " + (styleValue(value, receivedType)) + ".";
    }
    return message
  }

  function styleValue (value, type) {
    if (type === 'String') {
      return ("\"" + value + "\"")
    } else if (type === 'Number') {
      return ("" + (Number(value)))
    } else {
      return ("" + value)
    }
  }
  var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
  function isExplicable (value) {
    //将value转为小写,然后判断value是否是'string', 'number', 'boolean'的其中一种类型
    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; })
  }
  //判断是否为boolean类型
  function isBoolean () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];
    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
  }

  /* 捕捉异常 */
  // 首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured 方法。
  // 在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法
  function handleError (err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
      // vm指当前报错的组件实例
      if (vm) {
        var cur = vm;
      // 递归查找当前组件的父组件，依次调用errorCaptured 方法。
      // 在遍历调用完所有 errorCaptured 方法、或 errorCaptured 方法有报错时，调用 globalHandleError 方法
        while ((cur = cur.$parent)) {
          var hooks = cur.$options.errorCaptured;
          // 判断是否存在errorCaptured钩子函数
          if (hooks) {
            for (var i = 0; i < hooks.length; i++) {
              try {
                var capture = hooks[i].call(cur, err, vm, info) === false;
                if (capture) { return }
              } catch (e) {
                globalHandleError(e, cur, 'errorCaptured hook');
              }
            }
          }
        }
      }
      globalHandleError(err, vm, info);
    } finally {
      popTarget();
    }
  }
  // 异步错误处理
  function invokeWithErrorHandling (
    handler,
    context,
    args,
    vm,
    info
  ) {
    var res;
    try {
      //根据不同参数选择不同的处理函数
      res = args ? handler.apply(context, args) : handler.call(context);
      if (res && !res._isVue && isPromise(res) && !res._handled) {
        res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
        res._handled = true;
      }
    } catch (e) {
      handleError(e, vm, info);
    }
    return res
  }
  // 调用全局的 errorHandler 方法，生产环境下会使用 console.error 在控制台中输出
  function globalHandleError (err, vm, info) {
    // 获取全局配置，判断是否设置处理函数
    if (config.errorHandler) {
      try {
        // 执行设置的全局错误处理函数
        return config.errorHandler.call(null, err, vm, info)
      } catch (e) {
        // 如果开发者在errorHandler函数中手动抛出同样错误信息throw err判断err信息是否相等，避免log两次
        // 如果抛出新的错误信息将会一起log输出
        if (e !== err) {
          logError(e, null, 'config.errorHandler');
        }
      }
    }
    logError(err, vm, info);
  }
  // 判断环境，选择不同的抛错方式。浏览器或微信环境，并且console的类型为undefied时,打印error
  function logError (err, vm, info) {
    {
      warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
    }
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }

//接下来是nextTick的核心代码
// 使用 MicroTask（微任务） 的标识符
  var isUsingMicroTask = false;

  var callbacks = [];
  var pending = false;
  //依次同步执行callbacks中回调
  function flushCallbacks () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  /*在vue2.5之前的版本中，nextTick基本上基于 micro task 来实现的，但是在某些情况下 micro task 具有太高的优先级，
  并且可能在连续顺序事件之间（例如＃4521，＃6690）或者甚至在同一事件的事件冒泡过程中之间触发（＃6566）。
  但是如果全部都改成 macro task，对一些有重绘和动画的场景也会有性能影响，如 issue #6813。
  vue2.5之后版本提供的解决办法是默认使用 micro task，但在需要时（例如在v-on附加的事件处理程序中）强制使用 macro task*/
  var timerFunc;

//nextTick行为利用了可以访问的微任务队列
//通过本机Promise.then或MutationObserver。
//MutationObserver得到了更广泛的支持，但是它在
//iOS中的UIWebView>=9.3.3，当touch事件处理程序中触发时,几次后会完全停止工作
  /* istanbul ignore next, $flow-disable-line */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    timerFunc = function () {
      p.then(flushCallbacks);
      //在有问题的UIWebViews中，Promise.then并没有完全崩溃，但是
      //它可能会陷入一种奇怪的状态，即回调被推到
      //微任务队列，但在浏览器
      //需要做一些其他工作，例如处理计时器。所以我们可以
      //通过添加计时器“强制”刷新微任务队列。
      if (isIOS) { setTimeout(noop); }
    };
    isUsingMicroTask = true;
    // MutationObserver的作用通过它创建一个观察者对象，这个对象会监听某个DOM元素，并在它的DOM树发生变化时执行我们提供的回调函数
  } else if (!isIE && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter = 1;
    // 声明 MO 和回调函数
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    // 监听 textNode 这个文本节点，一旦文本改变则触发回调函数 nextTickHandler
    observer.observe(textNode, {
      characterData: true
    });
    // 每次执行 timeFunc 都会让文本在 1 和 0 间切换
    timerFunc = function () {
      counter = (counter + 1) % 2;
      //把该数据值赋值到data属性上面去，如果data属性发生改变了，就会重新渲染页面
      textNode.data = String(counter);
    };
    isUsingMicroTask = true;
  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // setImmediate使用宏任务
    timerFunc = function () {
      setImmediate(flushCallbacks);
    };
  } else {
    //如果不支持MutationObserver，则使用settimeout
    timerFunc = function () {
      setTimeout(flushCallbacks, 0);
    };
  }

  function nextTick (cb, ctx) {
    
    var _resolve;
    // 传入的cb是否是函数，ctx参数是否是一个对象，如果cb是一个函数的话，使用cb.call(ctx)
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    //如果pending为true，表明本轮事件循环中已经执行过 timerFunc(nextTickHandler, 0)
    if (!pending) {
      pending = true;
      timerFunc();
    }
    //判断是否有Promise对象
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      })
    }
  }

  /*  */

  var mark;
  var measure;
  // 此方法是获取标签在浏览器加载的时间快照
  {
    //在浏览器环境
    var perf = inBrowser && window.performance;
    //performance.mark方法在浏览器的性能条目缓冲区中创建一个具有给定名称的缓冲区，
    //performance.measure在浏览器的两个指定标记（分别称为起始标记和结束标记）之间的性能条目缓冲区中创建一个命名
    //performance.measure从浏览器的performance entry 缓存中移除声明的标记
    if (
      perf &&
      perf.mark &&
      perf.measure &&
      perf.clearMarks &&
      perf.clearMeasures
    ) {
      mark = function (tag) { return perf.mark(tag); };
      measure = function (name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
        // perf.clearMeasures(name)
      };
    }
  }

  /* not type checking this file because flow doesn't play well with Proxy */
//初始化代理
  var initProxy;

  {
    //makeMap 方法将字符串切割，放到map中，用于校验其中的某个字符串是否存在（区分大小写）于map中
    var allowedGlobals = makeMap(
      'Infinity,undefined,NaN,isFinite,isNaN,' +
      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
      'require' // for Webpack/Browserify
    );
    // 不存在，未定义的属性，方法被使用给出警告
    var warnNonPresent = function (target, key) {
      warn(
        "Property or method \"" + key + "\" is not defined on the instance but " +
        'referenced during render. Make sure that this property is reactive, ' +
        'either in the data option, or for class-based components, by ' +
        'initializing the property. ' +
        'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
        target
      );
    };
    //用于检测属性 key 的声明方法，是否是 $ 或者 _ 开头的，如果是，会给出警告
    var warnReservedPrefix = function (target, key) {
      warn(
        "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
        'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
        'prevent conflicts with Vue internals. ' +
        'See: https://vuejs.org/v2/api/#data',
        target
      );
    };

    var hasProxy =
      typeof Proxy !== 'undefined' && isNative(Proxy);
      //当前环境中的proxy可用
    if (hasProxy) {
      //某个字符串是否存在map中
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
      //config.keyCodes自定义按键修饰符
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set (target, key, value) {
          //key是否存在map中
          if (isBuiltInModifier(key)) {
            warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
            return false
          } else {
            target[key] = value;
            return true
          }
        }
      });
    }
     //这个函数主要是提示错误信息，在开发者错误的调用vm属性时，提供提示作用
    var hasHandler = {
      has: function has (target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) ||
          (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
        if (!has && !isAllowed) {
          if (key in target.$data) { warnReservedPrefix(target, key); }
          else { warnNonPresent(target, key); }
        }
        return has || !isAllowed
      }
    };
    // getHandler方法主要是针对读取代理对象的某个属性时进行的操作。
    // 当访问的属性不是string类型或者属性值在被代理的对象上不存在，则抛出错误提示，否则就返回该属性值
    var getHandler = {
      get: function get (target, key) {
        if (typeof key === 'string' && !(key in target)) {
          if (key in target.$data) { warnReservedPrefix(target, key); }
          else { warnNonPresent(target, key); }
        }
        return target[key]
      }
    };
    //初始化代理
    initProxy = function initProxy (vm) {
      // 通过判断hasProxy，来执行不同的处理逻辑
      if (hasProxy) {
        // 如果options上存在render属性，且render属性上存在_withStripped属性，
        // 则proxy的traps(traps其实也就是自定义方法)采用getHandler方法,否则采用hasHandler方法
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped
          ? getHandler
          : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }


  var seenObjects = new _Set();

  // 递归遍历对象以调用所有已转换的getter，以便对象中的每个嵌套属性,作为'deep'依赖项收集
  //这个函数主要用来进行深度监听
  function traverse (val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse (val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    // val是否是数组 或者是已经冻结对象或者是VNode实例
    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
      return
    }
    // 只有object和array才有__ob__属性
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;//手动依赖收集器的id
      if (seen.has(depId)) {
        return
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      // 递归触发每一项的get进行依赖收集
      while (i--) { _traverse(val[i], seen); }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      // 递归触发子属性的get进行依赖收集
      while (i--) { _traverse(val[keys[i]], seen); }
    }
  }

  // 主要用于将传入的带有特殊前缀的事件修饰符分解为具有特定值的事件对象
  // name属性:事件名称
  // once属性:是否一次性执行
  // capture属性:是否捕获事件
  // passive属性:是否使用被动模式
  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~';
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    }
  });
  //与normalizeEvent一起完成更新监听器的实现，是真正执行事件处理器调用的过程
  function createFnInvoker (fns, vm) {
    function invoker () {
      var arguments$1 = arguments;
      // invoker.fns用来存放所传入的处理器
      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          //处理器数组的调用
          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
        }
      } else {
        // 单个处理器的调用
        return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
      }
    }
    invoker.fns = fns;
    return invoker
  }
  //这个函数主要是修改监听配置，遍历on事件对新节点事件绑定注册事件，对旧节点移除事件监听
  function updateListeners (
    on,
    oldOn,
    add,
    remove$$1,
    createOnceHandler,
    vm
  ) {
    var name, def$$1, cur, old, event;
    // 遍历on事件对新节点事件绑定注册事件
    for (name in on) {
      def$$1 = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      if (isUndef(cur)) {
        warn(
          "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
          vm
        );
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur, vm);
        }
        if (isTrue(event.once)) {
          cur = on[name] = createOnceHandler(event.name, cur, event.capture);
        }
        //执行真正注册事件的执行函数，add的实现原理利用了原生 DOM 的 addEventListener
        add(event.name, cur, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    //遍历旧节点，对旧节点移除事件监听
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  // 把insert作为一个hooks属性保存到对应的Vnode的data上面，当该Vnode插入到父节点后会调用该hooks
  function mergeVNodeHook (def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook () {
      hook.apply(this, arguments);
      // 删除合并的钩子以确保它只被调用一次并防止内存泄漏
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // 没有已经存在的hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // 已经有一个invoker（已经是合并的调用程序）
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  // 获取原始值
  function extractPropsFromVNodeData (
    data,
    Ctor,
    tag
  ) {
    // 获取组件的定义的props对象，这里只提取原始值。验证和默认值在子组件本身中处理。
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return
    }
    var res = {};
    var attrs = data.attrs;//获取data的attrs属性
    var props = data.props;//获取data的props属性
    // 如果data有定义了attrs或者props属性
    if (isDef(attrs) || isDef(props)) {
      //遍历组件的props属性
      for (var key in propOptions) {
        // 如果key是是驼峰字符串，则转换为-格式
        var altKey = hyphenate(key);
        {
          //转换为小写格式
          var keyInLowerCase = key.toLowerCase();
          if (
            key !== keyInLowerCase &&
            attrs && hasOwn(attrs, keyInLowerCase)
          ) {
            tip(
              "Prop \"" + keyInLowerCase + "\" is passed to component " +
              (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
              " \"" + key + "\". " +
              "Note that HTML attributes are case-insensitive and camelCased " +
              "props need to use their kebab-case equivalents when using in-DOM " +
              "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
            );
          }
        }
        // 调用checkProp从props或attrs里拿对应的属性
        checkProp(res, props, key, altKey, true) ||
        checkProp(res, attrs, key, altKey, false);
      }
    }
    return res
  }
   //children 的规范化，simpleNormalizeChildren和normalizeChildren都是用来把children由树状结构变成一维数组
  // 模板编译器试图通过在编译时静态分析模板来最小化规范化的需要
  // 对于纯HTML标记，可以完全跳过规范化，因为生成的呈现函数保证返回Array<VNode>。有两种情况需要额外的规范化：
  // 当子级包含组件时-因为功能组件可能返回数组而不是单个根。在这种情况下，只需要一个简单的规范化—如果任何子对象是数组，
  // 我们就用Array.prototype.concat将整个对象展平。它保证只有1级深度，因为功能组件已经规范化了它们自己的子级
  function simpleNormalizeChildren (children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children)
      }
    }
    return children
  }

  // 2.当子级包含总是生成嵌套数组的构造时，例如<template>、<slot>、v-for，或者当子级由用户提供手写的呈现函数/JSX时。
  // 在这种情况下，需要完全正常化，以满足所有可能类型的儿童价值观。
  function normalizeChildren (children) {
    return isPrimitive(children)
      ? [createTextVNode(children)]
      : Array.isArray(children)
        ? normalizeArrayChildren(children)
        : undefined
  }
  // node节点的判断条件
  function isTextNode (node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment)
  }
  //children 的规范化，normalizeArrayChildren接收 2 个参数，children 表示要规范的子节点，nestedIndex 表示嵌套的索引
  function normalizeArrayChildren (children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    //遍历children,
    for (i = 0; i < children.length; i++) {
      //将单个节点赋值给c
      c = children[i];
      //判断c的类型，如果是一个数组类型，则递归调用 normalizeArrayChildren; 
      //否则通过 createTextVNode 方法转换成 VNode 类型；
      if (isUndef(c) || typeof c === 'boolean') { continue }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //如果是一个数组类型，则递归调用 normalizeArrayChildren
      if (Array.isArray(c)) {
        if (c.length > 0) {
          // 如果 children 是一个列表并且列表还存在嵌套的情况，则根据 nestedIndex 去更新它的 key
          c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + (c[0]).text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          //通过 createTextVNode 方法转换成 VNode 类型
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          if (isTrue(children._isVList) &&
            isDef(c.tag) &&
            isUndef(c.key) &&
            isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res
  }

  /* initProvide的作用就是将$options里的provide赋值到当前实例上 */

  function initProvide (vm) {
    //如果provide存在,当它是函数时执行该返回，否则直接将provide保存到Vue实例的_provided属性上
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function'
        ? provide.call(vm)
        : provide;
    }
  }
  //组件实例化，初始化Inject参数， initInjections在初始化data/props之前被调用，主要作用是初始化vue实例的inject
  function initInjections (vm) {
    //遍历祖先节点，获取对应的inject
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      // toggleObserving是vue内部对逻辑的一个优化,就是禁止掉根组件 props的依赖收集
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        //将key编程响应式，这样就可以访问该元素
        {
          defineReactive$$1(vm, key, result[key], function () {
            warn(
              "Avoid mutating an injected value directly since the changes will be " +
              "overwritten whenever the provided component re-renders. " +
              "injection being mutated: \"" + key + "\"",
              vm
            );
          });
        }
      });
      toggleObserving(true);
    }
  }
// 确定Inject，vm指当前组件的实例
  function resolveInject (inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
       //如果有符号类型，调用Reflect.ownKeys()返回所有的key，再调用filter
      var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);
      //获取所有的key，此时keys就是个字符串数组
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        // #6574 in case the inject object is observed...
        if (key === '__ob__') { continue }
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          //如果source存在_provided 且 含有provideKey这个属性，则将值保存到result[key]中
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break
          }
          // 否则将source赋值给父Vue实例，直到找到对应的providekey为止
          source = source.$parent;
        }
        // 如果最后source不存在，即没有从当前实例或祖先实例的_provide找到privideKey这个key
        if (!source) {
          // 如果有定义defult,则使用默认值
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function'
              ? provideDefault.call(vm)
              : provideDefault;
          } else {
            warn(("Injection \"" + key + "\" not found"), vm);
          }
        }
      }
      return result
    }
  }

  /*  */



  /**
   * 主要作用是将children VNodes转化成一个slots对象，处理组件slot，返回slot插槽对象
   * children指占位符Vnode里的内容
   * context指占位符Vnode所在的vue实例
   */
  function resolveSlots (
    children,
    context
  ) {
    // 判断是否有children，即是否有插槽VNode
    if (!children || !children.length) {
      return {}
    }
    var slots = {};
  // 遍历每一个子节点
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
    // data为VNodeData，保存父组件传递到子组件的props以及attrs等
      var data = child.data;
      //移出slot，删除该节点attrs的slot
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // 判断是否为具名插槽，如果为具名插槽，还需要 子组件 / 函数子组件 渲染上下文一致
      // 当需要向子组件的子组件传递具名插槽时，不会保持插槽的名字
      if ((child.context === context || child.fnContext === context) &&
        data && data.slot != null
      ) {
        var name = data.slot;
        var slot = (slots[name] || (slots[name] = []));
        //处理父组件采用template形式的插槽
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        //返回匿名default插槽VNode数组
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // 忽略仅仅包含whitespace的插槽
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots
  }
  // 方法用于判断指定字符是否为空白字符,空白符包含:空格、tab键、换行符
  function isWhitespace (node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' '
  }

  /* 是否为异步占位 */

  function isAsyncPlaceholder (node) {
    return node.isComment && node.asyncFactory
  }

  /*normalizeScopedSlots函数的核心就是返回res对象，其key为slotTarget,value为fn  */
  //slots： 某节点 data 属性上 scopedSlots
  //normalSlots： 当前节点下的普通插槽
  //prevSlots 当前节点下的特殊插槽
  function normalizeScopedSlots (
    slots,
    normalSlots,
    prevSlots
  ) {
    var res;
    //判断是否拥有普通插槽
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = slots ? !!slots.$stable : !hasNormalSlots;
    var key = slots && slots.$key;
    if (!slots) {
      res = {};
    } else if (slots._normalized) {
      return slots._normalized
    } else if (
      isStable &&
      prevSlots &&
      prevSlots !== emptyObject &&
       // slots $key 值与 prevSlots $key 相等
      key === prevSlots.$key &&
      //slots中没有普通插槽
      !hasNormalSlots &&
      //prevSlots中没有普通插槽
      !prevSlots.$hasNormal
    ) {
      return prevSlots
    } else {
      res = {};
      //遍历作用域插槽
      for (var key$1 in slots) {
        if (slots[key$1] && key$1[0] !== '$') {
          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
        }
      }
    }
    // 对普通插槽进行遍历，将slot代理到scopeSlots上
    for (var key$2 in normalSlots) {
      if (!(key$2 in res)) {
        res[key$2] = proxyNormalSlot(normalSlots, key$2);
      }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (slots && Object.isExtensible(slots)) {
      (slots)._normalized = res;
    }
    // $key , $hasNormal , $stable 是直接使用 vue 内部对 Object.defineProperty 封装好的 def() 方法进行赋值的
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res
  }
  //将scopeSlots对应属性和方法挂载到scopeSlots，生成闭包，返回一个名为normalized的函数，$scopedSlots对象中的值就是此函数
  function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function () {
      var res = arguments.length ? fn.apply(null, arguments) : fn({});
      res = res && typeof res === 'object' && !Array.isArray(res)
        ? [res] // single vnode
        : normalizeChildren(res);
      var vnode = res && res[0];
      return res && (
        !vnode ||
        (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391
      ) ? undefined
        : res
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
      Object.defineProperty(normalSlots, key, {
        get: normalized,
        enumerable: true,
        configurable: true
      });
    }
    return normalized
  }
  // 将slot代理到scopeSlots上
  function proxyNormalSlot(slots, key) {
    return function () { return slots[key]; }
  }

  /*  */

  /**
   * 用于呈现v-for列表的运行时帮助程序
   */
  function renderList (
    val,
    render
  ) {
    var ret, i, l, keys, key;
    //如果val为数组，则遍历val
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      // 调用传入的函数，把值传入，数组保存结果
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
      //如果val为数字类型
    } else if (typeof val === 'number') {
      ret = new Array(val);
      // 调用传入的函数，把值传入，数组保存结果
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
      //如果val为object类型,则遍历对象
    } else if (isObject(val)) {
      if (hasSymbol && val[Symbol.iterator]) {
        ret = [];
        var iterator = val[Symbol.iterator]();
        var result = iterator.next();
        // 调用传入的函数，把值传入，数组保存结果
        while (!result.done) {
          ret.push(render(result.value, ret.length));
          result = iterator.next();
        }
      } else {
        keys = Object.keys(val);
        ret = new Array(keys.length);
        for (i = 0, l = keys.length; i < l; i++) {
          key = keys[i];
          ret[i] = render(val[key], key, i);
        }
      }
    }
    if (!isDef(ret)) {
      ret = [];
    }
    (ret)._isVList = true;
    return ret
  }

  /*  */

  // 调用renderSlot用函数的返回值进行渲染
  // renderSlot函数会根据插槽名字找到对应的作用域Slot包装成的函数，
  // 然后执行它，把子组件内的数据{ child:child }传进去
  function renderSlot (
    name,//插槽名
    fallbackRender,//插槽默认内容生成的 vnode 数组
    props,// props 对象
    bindObject //v-bind 绑定对象
  ) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
      props = props || {};
      if (bindObject) {
        if (!isObject(bindObject)) {
          warn('slot v-bind without argument expects an Object', this);
        }
        props = extend(extend({}, bindObject), props);
      }
      nodes =
        scopedSlotFn(props) ||
        (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
    } else {
      nodes =
        this.$slots[name] ||
        (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes)
    } else {
      return nodes
    }
  }

  /*  */

  /**
   *找到我们写的过滤器，并将参数传入进去
   */
  function resolveFilter (id) {
    // resolveAsset用于获取资源，也就是获取组件的构造函数
    return resolveAsset(this.$options, 'filters', id, true) || identity
  }

  /* 检查按下的键，是否和配置的键值对匹配 */

  function isKeyNotMatch (expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1
    } else {
      return expect !== actual
    }
  }

  /**
   * 用于检查config.prototype中的键代码的运行时帮助程序，以Vue.prototype的形式公开
   */
  function checkKeyCodes (
    eventKeyCode,
    key,
    builtInKeyCode,
    eventKeyName,
    builtInKeyName
  ) {
     // 比如 key 传入的是自定义名字  aaaa
    // keyCode 从Vue 定义的 keyNames 获取 aaaa 的实际数字
    // keyName 从 Vue 定义的 keyCode 获取 aaaa 的别名
    // 并且以用户定义的为准，可以覆盖Vue 内部定义的
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    // 该键只在 Vue 内部定义的 keyCode 中
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName)
    // 该键只在 用户自定义配置的 keyCode 中
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode)
      //原始键名
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key
    }
    return eventKeyCode === undefined
  }


  /**
   * 用于将v-bind=“object”合并到VNode数据中的运行时帮助程序
   */
  function bindObjectProps (
    data,
    tag,
    value,
    asProp,
    isSync
  ) {
    if (value) {
      if (!isObject(value)) {
        warn(
          'v-bind without argument expects an Object or Array value',
          this
        );
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function ( key ) {
          if (
            key === 'class' ||
            key === 'style' ||
            isReservedAttribute(key)
          ) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key)
              ? data.domProps || (data.domProps = {})
              : data.attrs || (data.attrs = {});
          }
          var camelizedKey = camelize(key);
          var hyphenatedKey = hyphenate(key);
          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on[("update:" + key)] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) loop( key );
      }
    }
    return data
  }

  /*  */

  /**
   * 生成静态元素
   */
  function renderStatic (
    index,
    isInFor
  ) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
      return tree
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(
      this._renderProxy,
      null,
      this // for render fns generated for functional component templates
    );
    markStatic(tree, ("__static__" + index), false);
    return tree
  }

  /**
   * 标记v-once
   */
  function markOnce (
    tree,
    index,
    key
  ) {
    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
    return tree
  }
  // 标记静态元素
  function markStatic (
    tree,
    key,
    isOnce
  ) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], (key + "_" + i), isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }
  //标记静态节点
  function markStaticNode (node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /* //处理v-on=’{}'到vnode data上 */

  function bindObjectListeners (data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        warn(
          'v-on without argument expects an Object value',
          this
        );
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data
  }

  /* 获取作用域插槽 */

  function resolveScopedSlots (
    fns, // see flow/vnode
    res,
    // the following are added in 2.6
    hasDynamicKeys,
    contentHashKey
  ) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
      var slot = fns[i];
      if (Array.isArray(slot)) {
        resolveScopedSlots(slot, res, hasDynamicKeys);
      } else if (slot) {
        // marker for reverse proxying v-slot without scope on this.$slots
        if (slot.proxy) {
          slot.fn.proxy = true;
        }
        res[slot.key] = slot.fn;
      }
    }
    if (contentHashKey) {
      (res).$key = contentHashKey;
    }
    return res
  }

  /*//处理动态属性名  */

  function bindDynamicKeys (baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
      var key = values[i];
      if (typeof key === 'string' && key) {
        baseObj[values[i]] = values[i + 1];
      } else if (key !== '' && key !== null) {
        // null is a special value for explicitly removing a binding
        warn(
          ("Invalid value for dynamic directive argument (expected string or null): " + key),
          this
        );
      }
    }
    return baseObj
  }

  //处理修饰符
  // 帮助程序将修改器运行时标记动态追加到事件名称。
  // 请确保仅在值已为字符串时追加，否则将转换为字符串并导致类型检查丢失。
  function prependModifier (value, symbol) {
    return typeof value === 'string' ? symbol + value : value
  }

  /* 安装渲染工具函数，大多数服务于编译器编译出来的代码 */
  function installRenderHelpers (target) {
    target._o = markOnce;// 标记v-once
    target._n = toNumber;// 转换成Number类型
    target._s = toString;//转换成字符串
    target._l = renderList;//生成列表VNode
    target._t = renderSlot;//生成解析slot节点
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;//生成静态元素
    target._f = resolveFilter;// 获取过滤器
    target._k = checkKeyCodes;//检查键盘事件keycode
    target._b = bindObjectProps;//绑定对象属性
    target._v = createTextVNode;//创建文本VNod
    target._e = createEmptyVNode;//创建空节点VNode
    target._u = resolveScopedSlots;//获取作用域插槽
    target._g = bindObjectListeners;//处理v-on=’{}'到vnode data上
    target._d = bindDynamicKeys;//处理动态属性名
    target._p = prependModifier;//处理修饰符
  }

  /*  */
  //创建一个包含渲染要素的函数
  function FunctionalRenderContext (
    data,//组件的数据
    props,//父组件传递过来的数据
    children,//引用该组件时定义的子节点
    parent,
    Ctor//组件的构造对象(Vue.extend()里的那个Sub函数)
  ) {
    var this$1 = this;

    var options = Ctor.options;
    // 确保functional components中的createElement函数获得唯一的上下文
    var contextVm;
    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent);
      contextVm._original = parent;
    } else {
      //确保能够获得对真实上下文实例的保留
      contextVm = parent;
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      if (!this$1.$slots) {
        normalizeScopedSlots(
          data.scopedSlots,
          this$1.$slots = resolveSlots(children, parent)
        );
      }
      return this$1.$slots
    };

    Object.defineProperty(this, 'scopedSlots', ({
      enumerable: true,
      get: function get () {
        return normalizeScopedSlots(data.scopedSlots, this.slots())
      }
    }));

    // 对已编译函数模板的支持
    if (isCompiled) {
      // 公开renderStatic()的$options
      this.$options = options;
      // 预解析renderSlot()的插槽
      this.$slots = this.slots();
      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode
      };
    } else {
      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
    }
  }
  //渲染辅助函数
  installRenderHelpers(FunctionalRenderContext.prototype);
  //函数式组件的实现
  function createFunctionalComponent (
    Ctor,//Ctro:组件的构造对象(Vue.extend()里的那个Sub函数)
    propsData, //propsData:父组件传递过来的数据(还未验证)
    data,//data:组件的数据
    contextVm, //contextVm:Vue实例 
    children //children:引用该组件时定义的子节点
  ) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
     //如果propOptions非空(父组件向当前组件传入了信息),则遍历propOptions
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        // 调用validateProp()依次进行检验
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
      if (isDef(data.props)) { mergeProps(props, data.props); }
    }
    //创建一个函数的上下文
    var renderContext = new FunctionalRenderContext(
      data,
      props,
      children,
      contextVm,
      Ctor
    );
    //执行render函数，参数1为createElement，参数2为renderContext,也就是我们在组件内定义的render函数
    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      // 为了避免复用节点，fnContext 导致命名槽点不匹配的情况，
      // 直接在设置 fnContext 之前克隆节点，最后返回克隆好的 vnode
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
      }
      return res
    }
  }
  // 为了避免复用节点，fnContext 导致命名槽点不匹配的情况，
  // 直接在设置 fnContext 之前克隆节点，最后返回克隆好的 vnode
  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
    // 在设置fnContext之前克隆节点，否则，如果重复使用该节点
    // （例如，它来自缓存的正常插槽），fnContext将导致不应匹配的命名插槽。
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
    }
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone
  }
  // 将包含 VNode prop 的多个对象合并为一个单独的对象;
  function mergeProps (to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  //component初始化和更新的方法，
  // 是组件初始化的时候实现的几个钩子函数，分别有 init、prepatch、insert、destroy
  var componentVNodeHooks = {
    // 当 vnode 为 keep-alive 组件时、存在实例且没被销毁，为了防止组件流动，
    // 直接执行了 prepatch。否则直接通过执行 createComponentInstanceForVnode 
    // 创建一个 Component 类型的 vnode 实例，并进行 $mount 操作
    init: function init (vnode, hydrating) {
      if (
        vnode.componentInstance &&
        !vnode.componentInstance._isDestroyed &&
        vnode.data.keepAlive
      ) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        //根据Vnode生成VueComponent实例
        var child = vnode.componentInstance = createComponentInstanceForVnode(
          vnode,
          activeInstance
        );
        //将VueComponent实例挂载到dom节点上，本文是挂载到<my-component></my-component>节点
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },
    // 将已有组件更新成最新的 vnode 上的数据
    prepatch: function prepatch (oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(
        child,
        options.propsData, // 更新props
        options.listeners, // 更新listeners
        vnode, // 创建父节点
        options.children //创建子节点
      );
    },
    //insert钩子函数
    insert: function insert (vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      //判断组件实例是否已经被mounted,
      if (!componentInstance._isMounted) {
        // 直接将componentInstance作为参数执行mounted钩子函数
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      //如果组件为kepp-alive内置组件
      if (vnode.data.keepAlive) {
        //如果组件已经mounted
        if (context._isMounted) {
          // 为了防止 keep-alive 子组件更新触发 activated 钩子函数，
          // 直接就放弃了 walking tree 的更新机制，而是直接将组件实例 componentInstance 
          // 丢到 activatedChildren 这个数组中
          queueActivatedComponent(componentInstance);
        } else {
          // 否则直接出发activated钩子函数进行mounted
          activateChildComponent(componentInstance, true);
        }
      }
    },
    // 组件销毁函数
    destroy: function destroy (vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        // 如果不是 keep-alive 组件，直接执行 $destory 销毁组件实例，
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
          // 否则触发 deactivated 钩子函数进行销毁
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent (
    Ctor,
    data,
    context,
    children,
    tag
  ) {
    if (isUndef(Ctor)) {
      return
    }

    var baseCtor = context.$options._base;

    // 普通选项对象：将其转换为构造函数
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // 如果在此阶段不是构造函数或异步组件工厂则提示
    if (typeof Ctor !== 'function') {
      {
        warn(("Invalid Component definition: " + (String(Ctor))), context);
      }
      return
    }

    // 异步组件
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      // 处理了 3 种异步组件的创建方式
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
      if (Ctor === undefined) {
        // 异步组件 patch，创建一个注释节点作为占位符
        return createAsyncPlaceholder(
          asyncFactory,
          data,
          context,
          children,
          tag
        )
      }
    }
    data = data || {};
    // 解析constructor上的options属性
    resolveConstructorOptions(Ctor);
    //将组件v-modal数据转换为props和events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    //提取props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    //创建虚拟dom组件
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children)
    }

    // 提取侦听器，因为这些侦听器需要作为子组件侦听器而不是DOM侦听器
    var listeners = data.on;
    // 替换为带有.native修饰符的侦听器，以便在父组件修补程序期间对其进行处理
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // 抽象组件只保留props、侦听器和插槽
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // 在占位符节点上安装组件管理挂钩
    installComponentHooks(data);

    // 返回一个占位符节点
    var name = Ctor.options.name || tag;
    var vnode = new VNode(
      ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
      data, undefined, undefined, undefined, context,
      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
      asyncFactory
    );

    return vnode
  }

  function createComponentInstanceForVnode (
     // 当前组件的vnode
    vnode,
    // 当前的vue实例 就是div#app，也就是当前组件的父vue实例
    parent
  ) {
    // 增加 component 特有options
    var options = {
      _isComponent: true,
      _parentVnode: vnode,// 这里就是站位父VNode，也就是app.vue的占位符
      parent: parent// vue实例
    };
    // 检查内联模板渲染函数
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options)
  }
  // 安装组件钩子函数，等待patch过程时去执行
  function installComponentHooks (data) {
    var hooks = data.hook || (data.hook = {});
    // 遍历hooksToMerge，不断向data.hook插入componentVNodeHooks对象中对应的钩子函数
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var existing = hooks[key];
      var toMerge = componentVNodeHooks[key];
      if (existing !== toMerge && !(existing && existing._merged)) {
        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
      }
    }
  }

  function mergeHook$1 (f1, f2) {
    var merged = function (a, b) {
      f1(a, b);
      f2(a, b);
    };
    merged._merged = true;
    return merged
  }

  // 将组件v-modal（值和回调）转换为prop和event。
  function transformModel (options, data) {
    // 默认prop是value
    var prop = (options.model && options.model.prop) || 'value';
    // 默认event是Input
    var event = (options.model && options.model.event) || 'input';
     // 保存到props属性中
    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
     // 将input事件添加到on对象中
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
      if (
        Array.isArray(existing)
          ? existing.indexOf(callback) === -1
          : existing !== callback
      ) {
        on[event] = [callback].concat(existing);
      }
    } else {
      on[event] = callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // 包装器函数，用于提供更灵活的接口
  function createElement (
    context,
    tag,
    data,
    children,
    normalizationType,
    alwaysNormalize
  ) {
    // 首先检测data的类型，通过判断data是不是数组，以及是不是基本类型，来判断data是否传入
    // 如果传入，则将所有的参数向前赋值
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    // 首先判断data是不是响应式的，vnode中的data不能是响应式的。如果是，则Vue抛出警告
    return _createElement(context, tag, data, children, normalizationType)
  }
  
  function _createElement (
    context,//context表示vnode上上线文环境
    tag,
    data,//vnode数据
    children,//当前vnode子节点
    normalizationType
  ) {
    // 首先判断data是不是响应式的，vnode中的data不能是响应式的。如果是，则Vue抛出警告
    if (isDef(data) && isDef((data).__ob__)) {
      warn(
        "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
        'Always create fresh vnode data objects in each render!',
        context
      );
      return createEmptyVNode()
    }
    //v-bind中的对象语法
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // 如果是组件：则设置为falsy值
      return createEmptyVNode()
    }
    // 如果data.key不属于基本类型，则发出警告
    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)
    ) {
      {
        warn(
          'Avoid using non-primitive value as key, ' +
          'use string/number value instead.',
          context
        );
      }
    }
    // 支持单功能子项作为默认作用域插槽
    if (Array.isArray(children) &&
      typeof children[0] === 'function'
    ) {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    // 当alwaysNormalize等于2的时候，调用normalizeChildren去处理children类数组
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
      // 当alwaysNormalize等于1的时候，调用调用normalizeChildren去处理children类数组
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    // 判断tag的类型，如果是string就创建普通dom
    if (typeof tag === 'string') {
      var Ctor;
      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // 如果存在data.nativeOn并且data.tag不等于component时，发出警告
        if (isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
          warn(
            ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
            context
          );
        }
        vnode = new VNode(
          config.parsePlatformTagName(tag), data, children,
          undefined, undefined, context
        );
      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        //创建组件
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // 未知或未列出的命名空间元素在运行时检查，因为当其父元素规范化子元素时，可能会为其分配命名空间
        vnode = new VNode(
          tag, data, children,
          undefined, undefined, context
        );
      }
    } else {
      // 如果不是string就会调用createComponent创建组件
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode
    } else if (isDef(vnode)) {
      //如果存在vnode和ns，则将ns赋值给vnode.ns
      if (isDef(ns)) { applyNS(vnode, ns); }
      if (isDef(data)) { registerDeepBindings(data); }
      return vnode
    } else {
      return createEmptyVNode()
    }
  }
  //通过递归的方法把ns赋值给vnode.ns
  function applyNS (vnode, ns, force) {
    vnode.ns = ns;
    // 如果vnode.tag等于foreignObject则ns赋值为undefined
    if (vnode.tag === 'foreignObject') {
      //在foreignObject中使用默认命名空间
      ns = undefined;
      force = true;
    }
    //如果vnode有子节点则进行递归循环
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (
          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  // 确保父级在深度绑定的样式和类在插槽节点上使用
  function registerDeepBindings (data) {
    if (isObject(data.style)) {
    //如果有data.style,则调用traverse进行深度监听
      traverse(data.style);
    }
    //如果有data.class,则调用traverse进行深度监听
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }
  function initRender (vm) {
    vm._vnode = null; // 子树的根
    vm._staticTrees = null; // v-once缓存树
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // 父树中的占位符节点
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    //将createElement fn绑定到此实例
    //这样我们就可以在其中获得适当的渲染上下文。
    //参数顺序：标记、数据、子项、规范化类型、alwaysNormalize
    //内部版本由从模板编译的渲染函数使用
    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
    // 规范化始终应用于公共版本，用于用户编写的渲染函数。
    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

    // $attrs&amp;$listeners已公开，以便更轻松地进行临时创建。它们需要是反应式的，以便使用它们的HOC始终得到更新
    var parentData = parentVnode && parentVnode.data;

    {
      // Vue的data监听，也是通过defineReactive$$1方法
      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  var currentRenderingInstance = null;

  function renderMixin (Vue) {
    // 里面是一些渲染时候的帮助方法，全部挂载到Vue.prototype上，比如创建空节点、创建文本节点、toNumber、toString等等
    installRenderHelpers(Vue.prototype);
    // 使用异步函数来执行
    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this)
    };
// 调用render函数
    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(
          _parentVnode.data.scopedSlots,
          vm.$slots,
          vm.$scopedSlots
        );
      }

      // 设置父vnode。这允许渲染函数具有访问权限添加到占位符节点上的数据。
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        // There's no need to maintain a stack because all render fns are called
        // separately from one another. Nested component's render fns are called
        // when parent component is patched.
        currentRenderingInstance = vm;
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // 返回错误渲染结果，或上一个vnode，以防止渲染错误导致空白组件
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } finally {
        currentRenderingInstance = null;
      }
      // 如果返回的数组只包含一个节点
      if (Array.isArray(vnode) && vnode.length === 1) {
        vnode = vnode[0];
      }
      // 如果渲染函数出错，则返回空vnode
      if (!(vnode instanceof VNode)) {
        if (Array.isArray(vnode)) {
          warn(
            'Multiple root nodes returned from render function. Render function ' +
            'should return a single root node.',
            vm
          );
        }
        //给vnode赋值一个空节点
        vnode = createEmptyVNode();
      }
      //设置父节点
      vnode.parent = _parentVnode;
      return vnode
    };
  }

  /* 是为了保证能找到异步组件上定义的组件对象而定义的函数 */

  function ensureCtor (comp, base) {
    // 如果发现它是普通对象，则直接通过 Vue.extend 将其转换成组件的构造函数
    if (
      comp.__esModule ||
      (hasSymbol && comp[Symbol.toStringTag] === 'Module')
    ) {
      comp = comp.default;
    }
    return isObject(comp)
      ? base.extend(comp)
      : comp
  }
  // 返回呈现的异步组件的占位符节点作为注释节点，但保留节点的所有原始信息，这些信息将用于异步服务器渲染和同步
  function createAsyncPlaceholder (
    factory,
    data,
    context,
    children,
    tag
  ) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node
  }

  function resolveAsyncComponent (
    factory,//factory:异步组件的函数
    baseCtor
  ) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp
    }
    // 工厂函数异步组件第二次执行这里时会返回factory.resolved
    if (isDef(factory.resolved)) {
      return factory.resolved
    }

    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
      // already pending
      factory.owners.push(owner);
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp
    }

    if (owner && !isDef(factory.owners)) {
      var owners = factory.owners = [owner];
      var sync = true;
      var timerLoading = null;
      var timerTimeout = null;

      (owner).$on('hook:destroyed', function () { return remove(owners, owner); });
      // 遍历contexts里的所有元素,依次调用该元素的$forceUpdate()方法 该方法会强制渲染一次
      var forceRender = function (renderCompleted) {
        for (var i = 0, l = owners.length; i < l; i++) {
          (owners[i]).$forceUpdate();
        }

        if (renderCompleted) {
          owners.length = 0;
          if (timerLoading !== null) {
            clearTimeout(timerLoading);
            timerLoading = null;
          }
          if (timerTimeout !== null) {
            clearTimeout(timerTimeout);
            timerTimeout = null;
          }
        }
      };
      //定义一个resolve函数
      var resolve = once(function (res) {
        // 缓存解析
        factory.resolved = ensureCtor(res, baseCtor);
        // 当这不是同步解析时调用回调
        if (!sync) {
          forceRender(true);
        } else {
          owners.length = 0;
        }
      });
       //定义一个reject函数
      var reject = once(function (reason) {
        warn(
          "Failed to resolve async component: " + (String(factory)) +
          (reason ? ("\nReason: " + reason) : '')
        );
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender(true);
        }
      });
      //执行factory()函数
      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (isPromise(res)) {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isPromise(res.component)) {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              timerLoading = setTimeout(function () {
                timerLoading = null;
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender(false);
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            timerTimeout = setTimeout(function () {
              timerTimeout = null;
              if (isUndef(factory.resolved)) {
                reject(
                  "timeout (" + (res.timeout) + "ms)"
                );
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // 在同步解决的情况下返回
      return factory.loading
        ? factory.loadingComp
        : factory.resolved
    }
  }

  /*获取第一个组件的子节点  */
  function getFirstComponentChild (children) {
    //循环子节点，判断子节点是否位异步占位符
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c
        }
      }
    }
  }
//初始化事件
  function initEvents (vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    //初始化父附加事件
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      //修改组件的监听器
      updateComponentListeners(vm, listeners);
    }
  }

  var target;
//添加监听事件
  function add (event, fn) {
    target.$on(event, fn);
  }
//移出自定义事件监听器
  function remove$1 (event, fn) {
    target.$off(event, fn);
  }
  // 在执行完回调之后，移除事件绑定
  function createOnceHandler (event, fn) {
    var _target = target;
    return function onceHandler () {
      var res = fn.apply(null, arguments);
      if (res !== null) {
        _target.$off(event, onceHandler);
      }
    }
  }
//更新组件的监听器
  function updateComponentListeners (
    vm,
    listeners,
    oldListeners
  ) {
    target = vm;
    // 调用updateListeners来修改监听配置
    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
    target = undefined;
  }

  function eventsMixin (Vue) {
    var hookRE = /^hook:/;
    // 监听事件
    Vue.prototype.$on = function (event, fn) {
      var vm = this;
      //当传入的监听事件为数组，则循环遍历调用$on,否则将监听事件和回调函数添加到事件处理中心_events对象中
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          vm.$on(event[i], fn);
        }
      } else {
        // 之前已经有监听event事件，则将此次监听的回调函数添加到其数组中，否则创建一个新数组并添加fn
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm
    };
    //监听事件，只监听1次, Vue中的事件机制,Vue中的事件机制本身就是一个订阅-发布模式的实现
    Vue.prototype.$once = function (event, fn) {
      var vm = this;
       // 定义监听事件的回调函数
      function on () {
        // 从事件中心移除监听事件的回调函数
        vm.$off(event, on); 
        // 执行回调函数
        fn.apply(vm, arguments);
      }
       // 这个赋值是在$off方法里会用到的
    // 比如我们调用了vm.$off(fn)来移除fn回调函数，然而我们在调用$once的时候，实际执行的是vm.$on(event, on)
    // 所以在event的回调函数数组里添加的是on函数，这个时候要移除fn，我们无法在回调函数数组里面找到fn函数移除，只能找到on函数
    // 我们可以通过on.fn === fn来判断这种情况，并在回调函数数组里移除on函数
      on.fn = fn;
      // 通过$on方法注册事件，$once最终调用的是$on，并且回调函数是on
      vm.$on(event, on);
      return vm
    };
    // 移除自定义事件监听器。
    // 如果没有提供参数，则移除所有的事件监听器；
    // 如果只提供了事件，则移除该事件所有的监听器；
    // 如果同时提供了事件与回调，则只移除这个回调的监听器。
    Vue.prototype.$off = function (event, fn) {
      var vm = this;
      //调用this.$off()没有传参数，则清空事件处理中心缓存的事件及其回调
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm
      }
      //当event为数组，则循环遍历调用$off,否则将监听事件和回调函数添加到事件处理中心_events对象中
      if (Array.isArray(event)) {
        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
          vm.$off(event[i$1], fn);
        }
        return vm
      }
     // 获取当前event里所有的回调函数
      var cbs = vm._events[event];
      // 如果不存在回调函数，则直接返回，因为没有可以移除监听的内容
      if (!cbs) {
        return vm
      }
      // 如果没有指定要移除的回调函数，则移除该事件下所有的回调函数
      if (!fn) {
        vm._events[event] = null;
        return vm
      }
      // 指定了要移除的回调函数
      var cb;
      var i = cbs.length;
      while (i--) {
        cb = cbs[i];
        // 在事件对应的回调函数数组里面找出要移除的回调函数，并从数组里移除
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1);
          break
        }
      }
      return vm
    };
    // 触发事件
    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip(
            "Event \"" + lowerCaseEvent + "\" is emitted in component " +
            (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
            "Note that HTML attributes are case-insensitive and you cannot use " +
            "v-on to listen to camelCase events when using in-DOM templates. " +
            "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
          );
        }
      }
      // 触发事件对应的回调函数列表
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
         // $emit方法可以传参，这些参数会在调用回调函数的时候传进去
        var args = toArray(arguments, 1);
        var info = "event handler for \"" + event + "\"";
        // 遍历回调函数列表，调用每个回调函数
        for (var i = 0, l = cbs.length; i < l; i++) {
          invokeWithErrorHandling(cbs[i], vm, args, vm, info);
        }
      }
      return vm
    };
  }
  var activeInstance = null;
  var isUpdatingChildComponent = false;
  //设置当前的Vue实例 其返还结果为恢复上一个Vue实例,类似栈的思想来进行树状结构的构建
  function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
      activeInstance = prevActiveInstance;
    }
  }
  //方法主要用来初始化生命周期相关的属性，以及为parent,child属性赋值
  function initLifecycle (vm) {
    // 定义 options，它是 vm.$options 的引用，后面的代码使用的都是 options 常量
    var options = vm.$options;
    // 查找第一个非抽象父级
    // 定义 parent，它引用当前实例的父实例
    var parent = options.parent;
    // 如果当前实例有父组件，且当前实例不是抽象的
    if (parent && !options.abstract) {
      //循环查找第一个非抽象的父组件
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      // 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，
      // 所以将当前实例 vm 添加到父级的 $children 属性里
      parent.$children.push(vm);
    }
    // 设置当前实例的 $parent 属性，指向父级
    vm.$parent = parent;
    // 设置 $root 属性，有父级就是用父级的 $root，否则 $root 指向自身
    vm.$root = parent ? parent.$root : vm;
    // 设置当前实例的 $children 属性为空数组
    vm.$children = [];
    // 设置当前实例的 $ref 属性为空对象
    vm.$refs = {};
    // 设置当前实例的 _watcher 属性为null
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }
   //混入生命周期相关属性和方法
  function lifecycleMixin (Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      // 存储数据做以后update用
      var vm = this;
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var restoreActiveInstance = setActiveInstance(vm);
      vm._vnode = vnode;
      //第一次渲染会调用vm.__patch__方法
      if (!prevVnode) {
        // 初始渲染
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
      } else {
        // 更新
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      restoreActiveInstance();
      // 更新参考
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // 如果parent是HOC，则也更新其$el
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // 调度程序调用更新的挂钩，以确保在父级的更新挂钩中更新子级
    };
    // 强制刷新的作用
    //迫使Vue实例重新渲染，注意它仅仅影响实例本身喝插入插槽内容的子组件，而不是所有的子组件
    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };
    // $destroy是组件内部销毁自己。
    // 清理它与其它实例的连接，解绑它的全部指令及事件监听器,
    // 断掉虚拟dom和真实dom之间的联系，并没有真正地回收这个vue实例
    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return
      }
      //回调触发beforeDestroy钩子函数
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      //从父对象中删除vm
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      //拆卸观察者，调用teardown方法移出watcher
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // 从数据中删除引用对象
      // 可能没有观察者
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      //在当前渲染树上调用销毁挂钩
      vm.__patch__(vm._vnode, null);
      //回调触发destroyed钩子函数
      callHook(vm, 'destroyed');
      //关闭所有实例的侦听器
      vm.$off();
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }
  // $mount函数会调用mountComponent方法
  function mountComponent (
    vm,
    el,//当前挂载的元素
    hydrating //和服务端渲染相关
  ) {
    vm.$el = el;
     // 如果没有!vm.$options.render方法，就创建一个空的VNODE，
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
          vm.$options.el || el) {
          warn(
            'You are using the runtime-only build of Vue where the template ' +
            'compiler is not available. Either pre-compile the templates into ' +
            'render functions, or use the compiler-included build.',
            vm
          );
        } else {
          warn(
            'Failed to mount component: template or render function not defined.',
            vm
          );
        }
      }
    }
    //回调触发beforeMount钩子函数
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    // 如果config中配置了performance（记录性能）
    if (config.performance && mark) {
      updateComponent = function () {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;
        //开始标记
        mark(startTag);
        var vnode = vm._render();
         //开始结束
        mark(endTag);
        // measure方法是在执行了Performance的measure方法后，把开始结束两个mark值删除
        measure(("vue " + name + " render"), startTag, endTag);

        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure(("vue " + name + " patch"), startTag, endTag);
      };
    } else {
      updateComponent = function () {
        vm._update(vm._render(), hydrating);
      };
    }

    //将其设置为vm._watcher在watcher的构造函数中
    //因为观察者的初始补丁可能会调用$forceUpdate（例如，在child内部组件的挂载钩子），它依赖于已定义的vm.\u监视程序
    new Watcher(vm, updateComponent, noop, {
      // vm._isMounted 为 true,表示这个实例已经挂载了，执行 beforeUpdate 钩子函数
      before: function before () {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate');
        }
      }
    }, true);
    hydrating = false;

    //手动装入实例，调用自行装入
    //在插入的钩子中为渲染创建的子组件调用mounted
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm
  }
    //对占位符 vm.$vnode 的更新、slot的更新，listeners 的更新，props 的更新等
  function updateChildComponent (
    vm,
    propsData,
    listeners,
    parentVnode,
    renderChildren
  ) {
    {
      isUpdatingChildComponent = true;
    }

    // 确定组件是否具有插槽子级
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!(
      (newScopedSlots && !newScopedSlots.$stable) ||
      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
      (!newScopedSlots && vm.$scopedSlots.$key)
    );

    // 来自父级的任何静态插槽子级在父级的更新。动态作用域插槽也可能已更改。
    // 在这种情况下，需要强制更新以确保正确性
    var needsForceUpdate = !!(
      renderChildren ||               // 有一个新的静态插槽
      vm.$options._renderChildren ||  // 有一个旧的静态插槽
      hasDynamicScopedSlot
    );

    vm.$options._parentVnode = parentVnode;
    // 更新vm的占位符节点而不重新渲染
    vm.$vnode = parentVnode;
    // 更新子节点的父节点
    if (vm._vnode) { 
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // 更新$attrs和$listeners散列它们也是被动的，因此如果子对象在渲染期间使用它们，
    // 它们可能会触发子对象更新
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // 更新props
    if (propsData && vm.$options.props) {
      //禁止掉根组件 props的依赖收集
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props;
        //校验props
        props[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      // 保留一份原始的propsData
      vm.$options.propsData = propsData;
    }

    // 更新listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // 解决插槽和强制更新
    if (needsForceUpdate) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }
  //判断是否直接激活
  function isInInactiveTree (vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) { return true }
    }
    return false
  }
  // 激活子组件
  function activateChildComponent (vm, direct) {
    if (direct) {
      vm._directInactive = false;
      //判断是否直接激活
      if (isInInactiveTree(vm)) {
        return
      }
    } else if (vm._directInactive) {
      return
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      // 循环激活 vm.$children
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      // 调用 callHook(vm, 'activated')
      callHook(vm, 'activated');
    }
  }
  // 不激活组件
  function deactivateChildComponent (vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return
      }
    }
    // 判断是否是直接不激活
    if (!vm._inactive) {
      vm._inactive = true;
      // 循环不激活 vm.$children
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      // 调用 callHook(vm, "deactivated")
      callHook(vm, 'deactivated');
    }
  }
  // 先入栈操作，拿到 options.hook，处理错误问题，vm.$emit('hook:' + hook)，出栈操作
  function callHook (vm, hook) {
    // 在调用生命周期钩子时禁用dep收集
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        invokeWithErrorHandling(handlers[i], vm, null, vm, info);
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
  }

  /*  */

  var MAX_UPDATE_COUNT = 100;

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * 重置scheduler的状态.
   */
  function resetSchedulerState () {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }

  // 需要在附加事件监听器时保存时间戳。但是，调用performance.now()会带来性能开销，
  // 尤其是当页面有数千个事件监听器时。相反，我们在调度程序每次刷新时获取一个时间戳，并将其用于刷新期间附加的所有事件监听器。
  var currentFlushTimestamp = 0;

  // 异步边缘情况修复需要存储事件侦听器的附加时间戳
  var getNow = Date.now;

  // 确定浏览器正在使用的事件时间戳。恼人的是，时间戳可以是高分辨率(相对于页面加载)，
  // 也可以是低分辨率(相对于UNIX epoch)，所以为了比较时间，
  // 我们必须在保存刷新时间戳时使用相同的时间戳类型。所有IE版本都使用低分辨率的事件时间戳，并且时钟实现存在问题
  if (inBrowser && !isIE) {
    var performance = window.performance;
    if (
      performance &&
      typeof performance.now === 'function' &&
      getNow() > document.createEvent('Event').timeStamp
    ) {
      // 如果事件时间戳(尽管在Date.now()之后计算)小于它，则意味着事件使用的是高分辨率时间戳，
      // 我们也需要为事件侦听器的时间戳使用高分辨率版本。
      getNow = function () { return performance.now(); };
    }
  }

  /**
   * 清空两个队列并运行监视器。
   * 据变化最终会把flushSchedulerQueue传入到nextTick中执行
   * 遍历执行watcher.run()方法，watcher.run()方法最终会完成视图更新
   */
  function flushSchedulerQueue () {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;

    //在刷新之前对队列进行排序。为了确保:
    // 1。组件从父组件更新到子组件。(因为父母总是
    //在child之前创建
    // 2。组件的用户监视器在它的呈现监视器之前运行(因为
    //用户观察者在渲染观察者之前创建)
    // 3。如果一个组件在父组件的监视程序运行期间被销毁，
    //它的观察者可以被跳过。
    queue.sort(function (a, b) { return a.id - b.id; });

    //不要缓存长度，因为可能会有更多的监视器被推送
    //我们运行现有的观察者
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      if (watcher.before) {
        watcher.before();
      }
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // 在开发构建中，检查并停止循环更新。
      if (has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn(
            'You may have an infinite update loop ' + (
              watcher.user
                ? ("in watcher with expression \"" + (watcher.expression) + "\"")
                : "in a component render function."
            ),
            watcher.vm
          );
          break
        }
      }
    }

    // 在重置状态之前保留帖子队列的副本
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // 执行actived钩子函数
    callActivatedHooks(activatedQueue);
    //执行updated钩子函数
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }
  // 按索引递减的顺序执行_watcher关联实例的updated钩子
  function callUpdatedHooks (queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   *队列一个在补丁期间激活的保持活动的组件。
   *队列将在整个树被修补后进行处理。
   */
  function queueActivatedComponent (vm) {
    //将_inactive设置为false，这样渲染函数就可以
    //依赖于检查它是否在一个非活动的树(例如路由器视图)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks (queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * 将一个观察者推入观察者队列。具有重复id的作业将被跳过，除非它是在队列刷新时被推入。
   */
  function queueWatcher (watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // 如果已经刷新，则根据其id拼接监视程序
        // 如果已经超过了它的id，它将立即运行下一个
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      if (!waiting) {
        waiting = true;

        if (!config.async) {
          // 头尾插入代码来获取耗费时间
          flushSchedulerQueue();
          return
        }
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */



  var uid$2 = 0;

  /**
   * 观察者解析表达式，收集依赖项，并在表达式值改变时触发回调。这用于$watch() api和指令
   * Watcher 用于初始化数据的watcher的实列,他的原型上有个update用于派发更新
   */
  var Watcher = function Watcher (
    vm,
    expOrFn,
    cb,
    options,
    isRenderWatcher
  ) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // 用于懒惰的观察者
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // getter的解析表达式
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        warn(
          "Failed watching path: \"" + expOrFn + "\" " +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        );
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get();
  };

  /**
   * 评估getter，并重新收集依赖项。
   */
  Watcher.prototype.get = function get () {
    //将当前用户watch保存到Dep.target中
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      //执行用户wathcer的getter()方法，此方法会将当前用户watcher作为订阅者订阅起来
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
      } else {
        throw e
      }
    } finally {
      //"touch"每一个属性，所以他们都被跟踪
      //深度监视的依赖项
      if (this.deep) {
        traverse(value);
      }
      //恢复之前的watcher
      popTarget();
      this.cleanupDeps();
    }
    return value
  };

  /**
   *给这个指令添加一个依赖项.
   添加依赖（重点）
   */
  Watcher.prototype.addDep = function addDep (dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      //将依赖的每个dep，添加到 watcher 的 deps集合中，完成数据的收集
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * 清理依赖项集合.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    // 把 this.deps = this.newDeps，缓存到 deps 里，然后清空newDeps，来做下一次的收集
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * 更新数据的方法，在派发更新的时候会用到。 computed 更新数据的时候，用 dep 的 notify 方法进 
   * 行更新数据，更新数据主要调用的是 run 方法
   */
  Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * 在这个阶段主要是运行get方法，拿到数据
   */
  Watcher.prototype.run = function run () {
    if (this.active) {
      var value = this.get();
      if (
        value !== this.value ||
        // 深度观察者和对象/数组的观察者应该发射，当值相同时，因为值可能有突变。
        isObject(value) ||
        this.deep
      ) {
        //设置新的值
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          var info = "callback for watcher \"" + (this.expression) + "\"";
          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  // 用来重新计算，更新缓存值，并重置 dirty 为false，表示缓存已更新
  Watcher.prototype.evaluate = function evaluate () {
    this.value = this.get();
     // 执行完更新函数之后，立即重置标志
    this.dirty = false;
  };

  /**
   * 深度收集依赖，computed 可以收集 computed 数据就是依靠这个方法
   */
  Watcher.prototype.depend = function depend () {
    var i = this.deps.length;
    while (i--) {
      //注意这里的 depend 方法是 Dep 原型上的方法，不是Watcher 的法
      this.deps[i].depend();
    }
  };

  /**
   * 从所有依赖项的订阅者列表中删除self
   */
  Watcher.prototype.teardown = function teardown () {
    if (this.active) {
      // 从vm的监视列表中移除self这是一个有点昂贵的操作，所以我们跳过它，如果vm正在被销毁。
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
    }
  };

  //***************************************代理proxy*************************** */
  /* 初始化 */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };
  // 定义代理函数，target:当前对象,sourceKey:代理对象的名称,key:要访问的属性
  function proxy (target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter () {
      //访问vm[message]，就返回vm[data][message]
      return this[sourceKey][key]
    };
    //设值vm[message]，就变成设值vm[data][message]
    sharedPropertyDefinition.set = function proxySetter (val) {
      this[sourceKey][key] = val;
    };
    //通过defineProperty对vm[message]进行拦截,并将拦截的set和get方法通过sharedPropertyDefinition传进去
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }
  //初始化实例状态
  function initState (vm) {
    vm._watchers = [];
    var opts = vm.$options;
    //初始化props和methods
    if (opts.props) { initProps(vm, opts.props); }
    if (opts.methods) { initMethods(vm, opts.methods); }
    if (opts.data) {
      //把data属性注入到Vue实例上
      initData(vm);
    } else {
      // 调用observe(data)将data对象转化成响应式的对象
      observe(vm._data = {}, true /* asRootData */);
    }
    //初始化computed
    if (opts.computed) { initComputed(vm, opts.computed); }
    if (opts.watch && opts.watch !== nativeWatch) {
      //初始化watch
      initWatch(vm, opts.watch);
    }
  }

  function initProps (vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // 缓存props的key，以便将来的道具更新可以使用Array进行迭代，而不是使用动态对象键枚举。
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // 根实例道具需要被转换
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function ( key ) {
      keys.push(key);
      //用来处理校验规范，设置默认值，取值传递过来得参数值等操作
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        var hyphenatedKey = hyphenate(key);
        if (isReservedAttribute(hyphenatedKey) ||
            config.isReservedAttr(hyphenatedKey)) {
          warn(
            ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
            vm
          );
        }
        // 来处理props中参数得响应式
        defineReactive$$1(props, key, value, function () {
          if (!isRoot && !isUpdatingChildComponent) {
            warn(
              "Avoid mutating a prop directly since the value will be " +
              "overwritten whenever the parent component re-renders. " +
              "Instead, use a data or computed property based on the prop's " +
              "value. Prop being mutated: \"" + key + "\"",
              vm
            );
          }
        });
      }
      // 在Vue.extend()期间，静态道具已经被代理到组件的原型上了，只需要在这里实例化时定义的代理道具。
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) loop( key );
    toggleObserving(true);
  }
  // 运行 observe 函数深度遍历数据中的每一个属性，进行数据劫持
  function initData (vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function'
      ? getData(data, vm)
      : data || {};
    if (!isPlainObject(data)) {
      data = {};
      warn(
        'data functions should return an object:\n' +
        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
        vm
      );
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn(
            ("Method \"" + key + "\" has already been defined as a data property."),
            vm
          );
        }
      }
      if (props && hasOwn(props, key)) {
        warn(
          "The data property \"" + key + "\" is already declared as a prop. " +
          "Use prop default value instead.",
          vm
        );
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }
  
  function getData (data, vm) {
    // 在调用数据获取器时禁用dep收集
    pushTarget();
    try {
      return data.call(vm, vm)
    } catch (e) {
      handleError(e, vm, "data()");
      return {}
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = { lazy: true };
  // 始化computed的时候(initComputed)，会监测数据是否已经存在data或props上，如果存在则抛出警告，
  // 否则调用defineComputed函数，监听数据，为组件中的属性绑定getter及setter。如果computed中属性的值是一个函数，
  // 则默认为属性的getter函数。此外属性的值还可以是一个对象，他只有三个有效字段set、get和cache，
  // 分别表示属性的setter、getter和是否启用缓存，其中get是必须的，cache默认为true

  function initComputed (vm, computed) {
    var watchers = vm._computedWatchers = Object.create(null);
    // 计算属性只是SSR时期的getter
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if (getter == null) {
        warn(
          ("Getter is missing for computed property \"" + key + "\"."),
          vm
        );
      }

      if (!isSSR) {
        // 为computed属性创建内部监视器。
        watchers[key] = new Watcher(
          vm,
          getter || noop,
          noop,
          computedWatcherOptions
        );
      }

      // 如果定义的计算属性不在组件实例上，对属性进行数据劫持
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        // 如果定义的计算属性在data和props有，抛出警告
        if (key in vm.$data) {
          warn(("The computed property \"" + key + "\" is already defined in data."), vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
        } else if (vm.$options.methods && key in vm.$options.methods) {
          warn(("The computed property \"" + key + "\" is already defined as a method."), vm);
        }
      }
    }
  }
// 监听数据，为组件中的属性绑定getter及sette
  function defineComputed (
    target,
    key,
    userDef
  ) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache
        ? createComputedGetter(key)
        : createGetterInvoker(userDef);
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get
        ? shouldCache && userDef.cache !== false
          ? createComputedGetter(key)
          : createGetterInvoker(userDef.get)
        : noop;
      sharedPropertyDefinition.set = userDef.set || noop;
    }
    if (sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function () {
        warn(
          ("Computed property \"" + key + "\" was assigned to but it has no setter."),
          this
        );
      };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }
// 创建计算属性的getter函数computedGetter
  function createComputedGetter (key) {
    return function computedGetter () {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          //watcher.evaluate中更新watcher的值，并把watcher.dirty设置为false
                //这样等下次依赖更新的时候才会把watcher.dirty设置为true，然后进行取值的时候才会再次运行这个函数
          watcher.evaluate();
        }
        //依赖追踪
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value
      }
    }
  }

  function createGetterInvoker(fn) {
    // 没有缓存则直接执行computed的getter函数
    return function computedGetter () {
      return fn.call(this, this)
    }
  }
// 绑定了所有method的this为vm
  function initMethods (vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        if (typeof methods[key] !== 'function') {
          warn(
            "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
            "Did you reference the function correctly?",
            vm
          );
        }
        if (props && hasOwn(props, key)) {
          warn(
            ("Method \"" + key + "\" has already been defined as a prop."),
            vm
          );
        }
        if ((key in vm) && isReserved(key)) {
          warn(
            "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
            "Avoid defining component methods that start with _ or $."
          );
        }
      }
      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
  }
  // vm.$watch函数会直接使用Watcher构建观察者对象。watch中属性的值作为watcher.cb存在，在观察者update的时候，在watcher.run函数中执行
  function initWatch (vm, watch) {
    //遍历watch，为每一个属性创建侦听器
    for (var key in watch) {
      var handler = watch[key];
      //如果属性值是一个数组，则遍历数组，为属性创建多个侦听器
        //createWatcher函数中封装了vm.$watch，会在vm.$watch中创建侦听器
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        //为属性创建侦听器
        createWatcher(vm, key, handler);
      }
    }
  }
  function createWatcher (
    vm,
    expOrFn,
    handler,
    options
  ) {
    //如果属性值是一个对象，则取对象的handler属性作为回调
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    //如果属性值是一个字符串，则从组件实例上寻找
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    //为属性创建侦听器
    return vm.$watch(expOrFn, handler, options)
  }

  function stateMixin (Vue) {
    // 在使用object . defineproperty时，flow在直接声明定义对象方面有一些问题，所以我们必须在这里过程地构建对象。
    // 定义了dataDef和propsDef，主要是用来设置响应式d a t a 和 data和data和props的get和set方法
    var dataDef = {};
    dataDef.get = function () { return this._data };
    var propsDef = {};
    propsDef.get = function () { return this._props };
    {
      dataDef.set = function () {
        warn(
          'Avoid replacing instance root $data. ' +
          'Use nested data properties instead.',
          this
        );
      };
      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (
      expOrFn,
      cb,
      options
    ) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options)
      }
      options = options || {};
      options.user = true;
      options.user = true;
      //为需要观察的 expOrFn 添加watcher ，expOrFn的值有改变时执行cb，
      //在watcher的实例化的过程中会对expOrFn进行解析，并为expOrFn涉及到的data数据下的def添加该watcher
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        var info = "callback for immediate watcher \"" + (watcher.expression) + "\"";
        pushTarget();
        invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
        popTarget();
      }
       //取消观察函数
      return function unwatchFn () {
        watcher.teardown();
      }
    };
  }

  /*  */

  var uid$3 = 0;

  function initMixin (Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$3++;

      var startTag, endTag;
      /* istanbul ignore if */
      if (config.performance && mark) {
        startTag = "vue-perf-start:" + (vm._uid);
        endTag = "vue-perf-end:" + (vm._uid);
        mark(startTag);
      }

      // 如果是Vue的实例，则不需要被observe
      vm._isVue = true;
      // options参数的处理
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(
          resolveConstructorOptions(vm.constructor),
          options || {},
          vm
        );
      }
      /* istanbul ignore else */
      {
        initProxy(vm);
      }
      // expose real self
      vm._self = vm;
      // vm的生命周期相关变量初始化
      initLifecycle(vm);
      // vm的事件监听初始化
      initEvents(vm);
      // vm的编译render初始化
      initRender(vm);
      // vm的beforeCreate生命钩子的回调
      callHook(vm, 'beforeCreate');
      // vm在data/props初始化之前要进行绑定
      initInjections(vm); // resolve injections before data/props
      // vm的sate状态初始化
      initState(vm);
      // vm在data/props之后要进行提供
      initProvide(vm); // resolve provide after data/props
      // vm的created生命钩子的回调
      callHook(vm, 'created');

      /* istanbul ignore if */
      if (config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure(("vue " + (vm._name) + " init"), startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }
  // Vue初始化中的选项合并
  // 通过循环递归，找到Component这个类的继承链，然后把所有的配置都进行融合
  function initInternalComponent (vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // 该组件实例的vnode对象
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions (Ctor) {
    var options = Ctor.options;
    // 首先需要判断该类是否是Vue的子类
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
       // 来判断父类中的options 有没有发生变化
      if (superOptions !== cachedSuperOptions) {
        // 超级选项改变，需要解决新的选项
        Ctor.superOptions = superOptions;
        // 检查是否有任何后期修改/附加的选项
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          // 当为Vue混入一些options时，superOptions会发生变化，此时于之前子类中存储的cachedSuperOptions已经不相等，所以下面的操作主要就是更新sub.superOptions
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options
  }

  function resolveModifiedOptions (Ctor) {
    var modified;
    var latest = Ctor.options;
    // 执行Vue.extend时封装的"自身"options，这个属性就是方便检查"自身"的options有没有变化
    var sealed = Ctor.sealedOptions;
    // 遍历当前构造器上的options属性，如果在"自身"封装的options里没有，则证明是新添加的。执行if内的语句。
    // 调用dedupe方法，最终返回modified变量(即”自身新添加的options“)
  for (const key in latest) {
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) { modified = {}; }
        modified[key] = latest[key];
      }
    }
    return modified
  }
}

  function Vue (options) {
    if (!(this instanceof Vue)
    ) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
  }
  initMixin(Vue);// 初始化 Mixin
  stateMixin(Vue);// 状态 Mixin
  eventsMixin(Vue);// 事件 Mixin
  lifecycleMixin(Vue);// 生命周期 Mixin
  renderMixin(Vue);// 渲染 Mixin

  /*  Vue.use() 的注册本质上就是执行了一个 install 方法 */
  function initUse (Vue) {
    // 在全局api Vue 上定义了 use 方法，接收一个 plugin 参数
    Vue.use = function (plugin) {
      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
      if (installedPlugins.indexOf(plugin) > -1) {
        return this
      }

      // 用来判断该插件是不是已经注册过，防止重复注册
      var args = toArray(arguments, 1);
      args.unshift(this);
      // 判断 Vue.use() 传入的第一个参数是 Object 还是 Function
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this
    };
  }

  /* 将options和mixin合并 */

  function initMixin$1 (Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this
    };
  }

    /**
     * Vue.extend的原理以及初始化过程
     */

  function initExtend (Vue) {
    // 每个实例构造函数(包括Vue)都有一个唯一的cid。这使我们能够为原型继承创建包装子构造函数并缓存它们。
    Vue.cid = 0;
    var cid = 1;


    Vue.extend = function (extendOptions) {
      // extendOptions就是我我们传入的组件options
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
          // 每次创建完Sub构造函数后，都会把这个函数储存在extendOptions上的_Ctor中
          // 下次如果用再同一个extendOptions创建Sub时
          // 就会直接从_Ctor返回
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId]
      }
      //校验组件 名
      var name = extendOptions.name || Super.options.name;
      if (name) {
        validateComponentName(name);
      }
      // 创建Sub构造函数
      var Sub = function VueComponent (options) {
        this._init(options);
      };
      // 继承Super，如果使用Vue.extend，这里的Super就是Vue
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(
        Super.options,
        extendOptions
      );
       // 将组件的options和Vue的options合并，得到一个完整的options
    // 可以理解为将Vue的一些全局的属性，比如全局注册的组件和mixin，分给了Sub
      Sub['super'] = Super;

      // 将props和computed代理到了原型上
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

       // 继承Vue的global-api
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

     // 继承assets的api，比如注册组件，指令，过滤器
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // 在components里添加一个自己
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // 这些options保存起来
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

       // 设置缓存
      cachedCtors[SuperId] = Sub;
      return Sub
    };
  }
  //初始化自定义代理函数
  function initProps$1 (Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }
  //为组件的属性绑定setter和getter属性
  function initComputed$1 (Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /* 创建组件、指令、过滤器 */

  function initAssetRegisters (Vue) {
    //遍历 ASSET_TYPES 数组，为Vue 定义相应的方法
    // ASSET_TYPES 包含 directive  component  filter
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (
        id,
        definition
      ) {
         // 判断是否有第二个参数，没有的话去之前的option的组件或者指令
        if (!definition) {
          return this.options[type + 's'][id]
        } else {
          //判断是否是一个组件，校验组件名字
          if (type === 'component') {
            validateComponentName(id);
          }
           // 判断传入的是不是一个原始对象
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            // 把组件配置转换为组件的构造函数
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
           // 全局注册，存储资源赋值
          this.options[type + 's'][id] = definition;
          return definition
        }
      };
    });
  }
//获取组件的名字
  function getComponentName (opts) {
    return opts && (opts.Ctor.options.name || opts.tag)
  }
  // 检测name是否匹配
  function matches (pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1
    } else if (isRegExp(pattern)) {
      return pattern.test(name)
    }
    /* istanbul ignore next */
    return false
  }

  function pruneCache (keepAliveInstance, filter) {
    //获取keepAliveInstance的缓存
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var entry = cache[key];
      if (entry) {
        var name = entry.name;
        // name不符合filter条件的，同时不是目前渲染的vnode时，销毁vnode对应的组件实例（Vue实例），并从cache中移除
        if (name && !filter(name)) {
          //pruneCache 函数的核心就是去调用pruneCacheEntry
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry (
    cache,
    key,
    keys,
    current
  ) {
    // 通过cached$$1 = cache[key]` 获取头部数据对应的值 `vnode`，执行 `cached$$1.componentInstance.$destroy() 将组件实例销毁
    var entry = cache[key];
    if (entry && (!current || entry.tag !== current.tag)) {
      // 销毁vnode对应的组件实例
      entry.componentInstance.$destroy();
    }
    // 清空组件对应的缓存节点
    cache[key] = null;
    // 删除缓存中的头部数据 keys[0]
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    // 抽象组件，判断当前组件虚拟dom是否渲染成真实dom的关键
    abstract: true,
  // 定义include、exclude及max属性
  // include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
  // exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
  // max - 数字。最多可以缓存多少组件实例。
    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    methods: {
      cacheVNode: function cacheVNode() {
        var ref = this;
        var cache = ref.cache;
        var keys = ref.keys;
        var vnodeToCache = ref.vnodeToCache;
        var keyToCache = ref.keyToCache;
        if (vnodeToCache) {
          var tag = vnodeToCache.tag;
          var componentInstance = vnodeToCache.componentInstance;
          var componentOptions = vnodeToCache.componentOptions;
          cache[keyToCache] = {
            name: getComponentName(componentOptions),
            tag: tag,
            componentInstance: componentInstance,
          };
          keys.push(keyToCache);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
          this.vnodeToCache = null;
        }
      }
    },
    //在 keep-alive 的创建阶段， created钩子会创建一个cache对象，用来保存vnode节点
    created: function created () {
      this.cache = Object.create(null);
      this.keys = [];
    },
    // 在销毁阶段，destroyed 钩子则会调用pruneCacheEntry方法清除cache缓存中的所有组件实例
    destroyed: function destroyed () {
      for (var key in this.cache) {
        // 销毁vnode对应的组件实例
        pruneCacheEntry(this.cache, key, this.keys);
      }
    },

    mounted: function mounted () {
      var this$1 = this;

      this.cacheVNode();
      // 通过 watch 来监听 include 和 exclude，在其改变时调用 pruneCache 以修改 cache 缓存中的缓存数据
      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) { return matches(val, name); });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) { return !matches(val, name); });
      });
    },

    updated: function updated () {
      this.cacheVNode();
    },
    // 渲染阶段
    render: function render () {
      var slot = this.$slots.default;
      // 得到slot插槽中的第一个组件
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        //获取组件名称，优先获取组件的name字段，否则是组件的tag
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
         // 不需要缓存，则返回 vnode
          (include && (!name || !matches(include, name))) ||
          // excluded
          (exclude && name && matches(exclude, name))
        ) {
          return vnode
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
        // 同一个构造函数可能会被注册为不同的本地组件，所以单独使用cid是不够的
          ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
          : vnode.key;
        if (cache[key]) {
           // 有缓存则取缓存的组件实例
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
           // 无缓存则创建缓存
          this.vnodeToCache = vnode;
          this.keyToCache = key;
        }
          // keepAlive标记
        vnode.data.keepAlive = true;
      }
      return vnode || (slot && slot[0])
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive
  };

  // 初始化全局API
  function initGlobalAPI (Vue) {
    // config
    var configDef = {};
    // 给configDef添加了一个get属性，这个属性返回得是一个config对象，这个cofig对象里面，有n个属性
    configDef.get = function () { return config; };
    {
      // 给configDef添加了一个set属性,返回的一个警告
      configDef.set = function () {
        warn(
          'Do not replace the Vue.config object, set individual fields instead.'
        );
      };
    }
    // 为Vue的构造函数，添加一个要通过Object.defineProperty监听的属性config
    Object.defineProperty(Vue, 'config', configDef);

    // 公开util
    // 设置了一个公开的util对象，但是它不是公共的api，避免依赖
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive$$1
    };
    // 绑定全局API——Vue.set，Vue.delete，Vue.nextTick
    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    // 2.6 explicit observable API
    Vue.observable = function (obj) {
      observe(obj);
      return obj
    };

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // 这用于标识“基”构造函数，以便在Weex的多实例场景中扩展所有普通对象组件
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);
    // 初始化Vue.extend，Vue.mixin，Vue.extend
    // AssetRegisters就是component，directive，filter三者
    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue);
  // vue.prototype上挂载$isServer、$ssrContext、FunctionalRenderContext
  Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function get () {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext
    }
  });

  //为ssr运行时助手安装暴露FunctionalRenderContext
  Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });
  // 在vue 上挂载 version 属性
  Vue.version = '2.6.14';
  //检验是否存在'style','class'字符串
  var isReservedAttr = makeMap('style,class');

  // 应该使用props进行绑定的属性
  //检验是否存在'input','textarea','option','select','progress'字符串
  var acceptValue = makeMap('input,textarea,option,select,progress');
  //校验元素值是否通过prop指定
  var mustUseProp = function (tag, type, attr) {
    return (
      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
      (attr === 'selected' && tag === 'option') ||
      (attr === 'checked' && tag === 'input') ||
      (attr === 'muted' && tag === 'video')
    )
  };
//检验是否存在'contenteditable','draggable','spellcheck'字符串
  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
//检验是否存在'events','caret','typing','plaintext-only'字符串
  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

  var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false'
      ? 'false'
      // 允许content - itable的任意字符串值
      : key === 'contenteditable' && isValidContentEditableValue(value)
        ? value
        : 'true'
  };
//校验是否包含以下字符串
  var isBooleanAttr = makeMap(
    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,' +
    'truespeed,typemustmatch,visible'
  );

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
  };

  var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : ''
  };
  // 通过isFalsyAttrValue方法判断值是否是false与null，如果isFalsyAttrValue返回为true则表示传入的值
  var isFalsyAttrValue = function (val) {
    return val == null || val === false
  };

  /* class 转码获取vonde 中的staticClass 静态class 和class动态class转义成真实dom需要的class格式。然后返回class字符串 */
  function genClassForVnode (vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    // 
    return renderClass(data.staticClass, data.class)
  }

  function mergeClassData (child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class)
        ? [child.class, parent.class]
        : parent.class
    }
  }
  // 渲染calss 这里获取到已经转码的calss
  function renderClass (
    staticClass,
    dynamicClass
  ) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      // 转码 class，把数组格式，对象格式的calss 全部转化成 字符串格式
      return concat(staticClass, stringifyClass(dynamicClass))
    }
    /* istanbul ignore next */
    return ''
  }

  function concat (a, b) {
    return a ? b ? (a + ' ' + b) : a : (b || '')
  }
  // 转码 class，把数组格式，对象格式的calss 全部转化成 字符串格式
  function stringifyClass (value) {
    if (Array.isArray(value)) {
      // 数组字符串变成字符串，然后用空格 隔开 拼接 起来变成字符串
      return stringifyArray(value)
    }
    if (isObject(value)) {
      // 对象字符串变成字符串，然后用空格 隔开 拼接 起来变成字符串
      return stringifyObject(value)
    }
    if (typeof value === 'string') {
      return value
    }
    /* istanbul ignore next */
    return ''
  }
  // 数组字符串变成字符串，然后用空格 隔开 拼接 起来变成字符串
  function stringifyArray (value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) { res += ' '; }
        res += stringified;
      }
    }
    return res
  }
// 对象字符串变成字符串，然后用空格 隔开 拼接 起来变成字符串
  function stringifyObject (value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) { res += ' '; }
        res += key;
      }
    }
    return res
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };
//判断html标签
  var isHTMLTag = makeMap(
    'html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot'
  );

  //判断svg 标签
  var isSVG = makeMap(
    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
    true
  );
  // 判断tag是不是pre
  var isPreTag = function (tag) { return tag === 'pre'; };
 // 判断tag是不是html标签或者svg标签
  var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag)
  };
  function getTagNamespace (tag) {
    if (isSVG(tag)) {
      return 'svg'
    }
    // 对MathML的基本支持注意，它不支持其他MathML元素作为组件根
    if (tag === 'math') {
      return 'math'
    }
  }

  var unknownElementCache = Object.create(null);
  // 检查dom 节点的tag标签 类型 是否是VPre 标签 或者是判断是否是浏览器自带原有的标签
  function isUnknownElement (tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true
    }
    // 判断tag是不是html标签或者svg标签
    if (isReservedTag(tag)) {
      return false
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag]
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return (unknownElementCache[tag] = (
        el.constructor === window.HTMLUnknownElement ||
        el.constructor === window.HTMLElement
      ))
    } else {
      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * 查询一个元素选择器，如果他不是元素选择器则创建div
   */
  function query (el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        warn(
          'Cannot find element: ' + el
        );
        return document.createElement('div')
      }
      return selected
    } else {
      return el
    }
  }

  //创建一个真实的dom
  function createElement$1 (tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm
    }
    // False或null将删除该属性，但undefined不会
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm
  }
  // 创建由tagName 指定的HTML元素
  function createElementNS (namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName)
  }
  // 创建文本节点
  function createTextNode (text) {
    return document.createTextNode(text)
  }
  // 创建一个注释节点
  function createComment (text) {
    return document.createComment(text)
  }
  // 插入节点 在某个元素前面插入一个节点
  function insertBefore (parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }
  // 删除子节点
  function removeChild (node, child) {
    node.removeChild(child);
  }
  //添加子节点 尾部
  function appendChild (node, child) {
    node.appendChild(child);
  }
  // 获取父亲子节点dom
  function parentNode (node) {
    return node.parentNode
  }
  //获取下一个兄弟节点
  function nextSibling (node) {
    return node.nextSibling
  }
  //获取dom标签名称
  function tagName (node) {
    return node.tagName
  }
   //设置dom 文本
  function setTextContent (node, text) {
    node.textContent = text;
  }
  //设置组建样式的作用域
  function setStyleScope (node, scopeId) {
    node.setAttribute(scopeId, '');
  }
  // Object.freeze冻结对象
  var nodeOps = /*#__PURE__*/Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });

  /* ref是给元素或者子组件注册引用信息的 */

  var ref = {
    create: function create (_, vnode) {
      registerRef(vnode);
    },
    update: function update (oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy (vnode) {
      registerRef(vnode, true);
    }
  };
  // ref模块初始化时会执行registerRef函数
  function registerRef (vnode, isRemoval) {
    var key = vnode.data.ref;
    //如果没有定义ref属性，则直接返回
    if (!isDef(key)) { return }
    //当前的根Vue实例
    var vm = vnode.context;
     //优先获取vonde的组件实例(对于组件来说)，或者el(该Vnode对应的DOM节点，非组件来说)
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
       //如果不是移除,当在v-for之内时，则保存为数组形式
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
         //不是在v-for之内时,直接保存到refs对应的key属性上
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
  // 判断当前VNode可复用,销毁一个DOM节点并创建一个新的再插入是消耗非常大的，
  // 无论是DOM对象本身的复杂性还是操作引起的重绘重排，所以虚拟DOM的目标是尽可能复用现有DOM进行更新
  function sameVnode (a, b) {
    return (
      a.key === b.key &&
      a.asyncFactory === b.asyncFactory && (
        (
          a.tag === b.tag &&
          a.isComment === b.isComment &&
          // 这个涉及属性的更新，如果一个节点没有任何属性，即data为undefined，与一个有data属性的节点进行更新不如直接渲染一个新的
          isDef(a.data) === isDef(b.data) &&
          // 这个主要是input标签type属性异同判断，不同的type相当于不同的tag
          sameInputType(a, b)
        ) || (
          isTrue(a.isAsyncPlaceholder) &&
          isUndef(b.asyncFactory.error)
        )
      )
    )
  }
  //这个主要是input标签type属性异同判断，不同的type相当于不同的tag
  function sameInputType (a, b) {
    if (a.tag !== 'input') { return true }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
  }
  // 接收一个 children 数组，生成 key 与 index 索引对应的一个 map 表
  function createKeyToOldIdx (children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) { map[key] = i; }
    }
    return map
  }
  // patch核心函数
  // backend的nodeOps是节点的功能函数，包括createElement创建元素、removeChild删除子元素，
  // tagName获取到标签名等，backend的modules是vue框架用于分别执行某个渲染任务的功能函数
  function createPatchFunction (backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;
    // 循环hooks和modules
    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }
    // 将原有的节点，同时也是DOM节点包装成虚拟节点
    function emptyNodeAt (elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
    }
    // 创建remove函数
    // remove$$1函数作为一个对象，第一个参数是vnode所属的dom元素，第二个参数是监听器个数。
    // 内部实现remove函数拥有listeners属性，等到这个属性的值每一次减少直到0时将直接移除节点
    function createRmCb (childElm, listeners) {
      function remove$$1 () {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove$$1.listeners = listeners;
      return remove$$1
    }
    // 移除节点，先找到父节点，然后通过removeChild移除掉这个节点
    function removeNode (el) {
      var parent = nodeOps.parentNode(el);
      // 元素可能已经由于v-html / v-text而被删除
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }
    function isUnknownElement$$1 (vnode, inVPre) {
      return (
        !inVPre &&
        !vnode.ns &&
        !(
          config.ignoredElements.length &&
          config.ignoredElements.some(function (ignore) {
            return isRegExp(ignore)
              ? ignore.test(vnode.tag)
              : ignore === vnode.tag
          })
        ) &&
        // 检测是否未知el
        config.isUnknownElement(vnode.tag)
      )
    }

    var creatingElmInVPre = 0;
    // 创建新节点
    function createElm (
      vnode,
      insertedVnodeQueue,
      parentElm,
      refElm,
      nested,
      ownerArray,
      index
    ) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        //这个vnode在以前的渲染中使用过,现在它被用作一个新节点，覆盖它的榆树将导致
        //当它被用作插入时，潜在的补丁错误,引用节点。相反，我们在创建节点之前按需克隆节点对应的DOM元素。
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; //过渡进入检查
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn(
              'Unknown custom element: <' + tag + '> - did you ' +
              'register the component correctly? For recursive components, ' +
              'make sure to provide the "name" option.',
              vnode.context
            );
          }
        }

        vnode.elm = vnode.ns
          ? nodeOps.createElementNS(vnode.ns, tag)
          : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if (data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */);
        }
        // 调用init钩子后，如果vnode是子组件它应该创建一个子实例并挂载它。这个子组件也设置了占位符vnode的榆树。
        //在这种情况下，我们只需要返回元素就可以了。
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true
        }
      }
    }

    function initComponent (vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      
      if (isPatchable(vnode)) {
        // div#app的创建时会调用invokeCreateHooks
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // 根空的组件。跳过所有元素相关的模块，除了ref
        registerRef(vnode);
        // 确保调用了插入钩子
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // 重新激活的内部转换组件不触发，因为内部节点创建的钩子没有被调用一次。
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break
        }
      }
      // 与新创建的组件不同，重新激活的keep-alive组件不插入自己
      insert(parentElm, vnode.elm, refElm);
    }
    // 通过insertBefore或者appendChild添加元素
    function insert (parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (nodeOps.parentNode(ref$$1) === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }
```